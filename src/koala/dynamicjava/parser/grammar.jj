/* -*- Java -*- */
// Parser options
//
options {
  JAVA_UNICODE_ESCAPE    = true;
  STATIC                 = false;
  JDK_VERSION            = "1.5";
}

PARSER_BEGIN(Parser)
  package koala.dynamicjava.parser.impl;

import java.lang.reflect.Modifier;
import java.util.*;
import java.io.File;
import edu.rice.cs.plt.tuple.Option;

import koala.dynamicjava.parser.wrapper.*;
import koala.dynamicjava.tree.*;
import koala.dynamicjava.tree.visitor.*;
import koala.dynamicjava.util.*;
import koala.dynamicjava.tree.tiger.*;

/**
 * This class represents a (interpreted) Java 1.1 language parser
 * adapted for 1.5 language extensions.
 */

public class Parser {
  /**
   * The name of the file currently interpreted; null by default
   */
  private File file = null;
  
  /**
   * A flag to use in semantic lookaheads.  Declared here as a workaround because 
   * lookahead can't access local variables or production parameters.
   */
  private boolean lookaheadFlag;
  /**
   * An environment that has the generic type parameters defined
   * at any point.
   *
   * Used as a stack, pushed if TypeParameters are parsed (in
   * a class/interface/method declaration), and popped after
   * parsing whole scope (class, interface, or method).
   */
  private Environment<String, TypeParameter> GenericTypesEnv =
    new EmptyEnv<String, TypeParameter>();
  
  private Map<String, TypeParameter> TypeParamsMap = new HashMap<String, TypeParameter>();
  // contains the latest defined type parameters list whose
  // full declaration has not finished yet. That is to take
  // care of the fact that the scope of a type parameter
  // covers the rest of the definition of the type parameters
  // list beyond a parameter's own definition (for example,
  // class Enum<E extends Enum<E>>, in Java 1.5 API). When
  // checking for a type parameter, this Map has to be checked
  // first before the GenericTypesEnv environment.
  
  boolean lastFormalParameterIsVarArgs = false;
  
  /**
   * The message reader
   */
  private LocalizedMessageReader reader =
    new LocalizedMessageReader("koala.dynamicjava.parser.resources.messages");
  
  /** Sets the current file */
  public void setFile(File f) { file = f; }
  
  private SourceInfo _range(Token first, Token last) {
    return SourceInfo.range(file, first.beginLine, first.beginColumn, last.endLine, last.endColumn);
  }
  
  /**
   * Throws a parse exception with the given message at the current token
   * @param message - the message to be thrown
   */
  
  private void _throwParseException(String message) throws ParseException {
    // The error typically occurs on the next token.
    Token t = token;
    if (token.next != null) {
      t = token.next;
    }
    // If a certain token or sequence of tokens is expected, display it.
    ParseException pe = generateParseException();
    throw new CustomParseException(message, t, pe.expectedTokenSequences, tokenImage);
  }
  
  /**
   * Throws a parse exception with the given message at the current token, if the given
   * parse exception was one auto generated by the parser (not one of ours), but not if the
   * message is an <EOF> message, which is passed up to allow continuation of typing
   * @param pe - the previous parse exception thrown
   * @param message - the message to be thrown
   */
  private void _throwParseException(ParseException pe, String message) throws ParseException {
    // Use the embedded error message if thrown from our code, or if ends in EOF
    if (pe instanceof CustomParseException) {
      message = pe.getMessage();
    }
    if(pe.getMessage().indexOf("<EOF>\"") != -1) {
      message = "Encountered Unexpected \"<EOF>\"";
    }
    _throwParseException(message);
  }
  
  /**
   * Creates a primary expression from a refix and a list of suffixes
   * @param prefix   the prefix expression
   * @param suffixes the suffix list built in reverse order
   */
  private static Expression createPrimaryExpression(Expression prefix, List<ExpressionSuffix> suffixes) {
    Iterator<ExpressionSuffix> it = suffixes.iterator();
    if (it.hasNext()) {
      return it.next().createExpression(prefix, it);
    } else {
      if (prefix instanceof CompileTimeQualifiedName) {
        return ((CompileTimeQualifiedName)prefix).createFieldAccess();
      } else if (prefix instanceof CompileTimeExpression) {
        return ((CompileTimeExpression)prefix).createRuntimeExpression();
      } else {
        return prefix;
      }
    }
  }
  
  /**
   * Creates a field declaration
   */
  private FieldDeclaration createFieldDeclaration(ModifierFlags  mf,
                                                  TypeName           typ,
                                                  Token          name,
                                                  Expression     exp,
                                                  int            dim) {
    SourceInfo si;
    int flags = 0;
    
    // Compute the position of the declaration in the source code
    if (mf != null) {
      si = mf.getSourceInfo();
      flags = mf.accessFlags;
    } else {
      si = typ.getSourceInfo();
    }
    
    if (exp != null) {
      si = SourceInfo.span(si, exp);
    } else {
      si = SourceInfo.extend(si, name.endLine, name.endColumn);
    }
    
    // If the field is an array, create an array type node
    if (dim > 0) {
      typ = new ArrayTypeName(typ, dim, false, typ.getSourceInfo());
    }
    
    return new FieldDeclaration(flags, typ, name.image, exp, si);
  }
  
  /**
   * Creates a variable declaration
   */
  private VariableDeclaration createVariableDeclaration(Token          mf,
                                                        TypeName           typ,
                                                        Token          name,
                                                        Expression     exp,
                                                        int            dim) {
    SourceInfo si;
    boolean isFinal = false;
    
    // Compute the position of the declaration in the source code
    if (mf != null) {
      si = _range(mf, mf);
      isFinal = true;
    } else {
      si = typ.getSourceInfo();
    }
    
    if (exp != null) {
      si = SourceInfo.span(si, exp);
    } else {
      si = SourceInfo.extend(si, name.endLine, name.endColumn);
    }
    
    // If the variable contains an array, create an array type node
    if (dim > 0) {
      typ = new ArrayTypeName(typ, dim, false, typ.getSourceInfo());
    }
    
    return new VariableDeclaration(isFinal, typ, name.image, exp, si);
  }
  
  
  private void checkModifiers(int flags, int notAllowed) throws ParseException {
    if(Modifier.isPublic(flags) && Modifier.isPublic(notAllowed))
      _throwParseException("Modifier public is not allowed here");
    if(Modifier.isPrivate(flags) && Modifier.isPrivate(notAllowed))
      _throwParseException("Modifier private is not allowed here");
    if(Modifier.isProtected(flags) && Modifier.isProtected(notAllowed))
      _throwParseException("Modifier protected is not allowed here");
    if(Modifier.isAbstract(flags) && Modifier.isAbstract(notAllowed))
      _throwParseException("Modifier abstract is not allowed here");
    if(Modifier.isFinal(flags) && Modifier.isFinal(notAllowed))
      _throwParseException("Modifier final is not allowed here");
    if(Modifier.isStatic(flags) && Modifier.isStatic(notAllowed))
      _throwParseException("Modifier static is not allowed here");
    if(Modifier.isNative(flags) && Modifier.isNative(notAllowed))
      _throwParseException("Modifier native is not allowed here");
    if(Modifier.isSynchronized(flags) && Modifier.isSynchronized(notAllowed))
      _throwParseException("Modifier synchronized is not allowed here");
    if(Modifier.isTransient(flags) && Modifier.isTransient(notAllowed))
      _throwParseException("Modifier transient is not allowed here");
    if(Modifier.isVolatile(flags) && Modifier.isVolatile(notAllowed))
      _throwParseException("Modifier volatile is not allowed here");
  }
  
  
  /*
   * The classes derived from this one are used for parsing only
   */
  
  abstract class ExpressionSuffix {
    /**
     * Creates an expression node
     * @param prefix the prefix expression
     * @param it     an iterator over the suffixes
     */
    public abstract Expression createExpression(Expression prefix, Iterator<ExpressionSuffix> it);
  }
  
  class DotAllocationSuffix extends ExpressionSuffix {
    /**
     * The allocation expression
     */
    public SimpleAllocation alloc;
    
    /**
     * Creates a new suffix
     * @param exp the expression
     */
    public DotAllocationSuffix(SimpleAllocation sa) {
      alloc = sa;
    }
    
    /**
     * Creates an expression node
     * @param prefix the prefix expression
     * @param it     an iterator over the suffixes
     */
    public Expression createExpression(Expression prefix, Iterator<ExpressionSuffix> it) {
      Expression exp = prefix;
      if (it.hasNext()) {
        exp = (it.next()).createExpression(prefix, it);
      } else {
        if (prefix instanceof CompileTimeExpression) {
          exp = ((CompileTimeExpression)prefix).createRuntimeExpression();
        }
      }
      
      ReferenceTypeName creationType = alloc.getCreationType();
      String name = creationType.getRepresentation();
      // TODO: Generate an appropriate error if name is qualified (contains '.')
      List<? extends TypeName> classTargs = null;
      if (creationType instanceof GenericReferenceTypeName) {
        // TODO: We assume here that the typeArguments list has length 1; check that
        // (or implement the whole thing without parsing a SimpleAllocation)
        classTargs = ((GenericReferenceTypeName) creationType).getTypeArguments().get(0);
      }
      List<Expression> args = alloc.getArguments();
      
      if (alloc instanceof PolymorphicAnonymousAllocation) {
        PolymorphicAnonymousAllocation cast = (PolymorphicAnonymousAllocation) alloc;
        return new PolymorphicAnonymousInnerAllocation(exp, name, classTargs, args,
                                                       cast.getMembers(), cast.getTypeArguments(),
                                                       SourceInfo.span(exp, alloc));
      }
      else if (alloc instanceof AnonymousAllocation) {
        return new AnonymousInnerAllocation(exp, name, classTargs, args,
                                            ((AnonymousAllocation) alloc).getMembers(),
                                            SourceInfo.span(exp, alloc));
      }
      else if (alloc instanceof PolymorphicSimpleAllocation) {
        return new PolymorphicInnerAllocation(exp, name, classTargs, args,
                                              ((PolymorphicSimpleAllocation) alloc).getTypeArguments(),
                                              SourceInfo.span(exp, alloc));

      }
      else {
        return new InnerAllocation(exp, name, classTargs, args, SourceInfo.span(exp, alloc));
      }
    }
  }
  
  class DotIdentifierSuffix extends ExpressionSuffix {
    /**
     * The identifier
     */
    public Token identifier;
    
    /**
     * Creates a new suffix
     * @param ident the identifier
     */
    public DotIdentifierSuffix(Token ident) {
      identifier = ident;
    }
    
    /**
     * Creates an expression node
     * @param prefix the prefix expression
     * @param it     an iterator over the suffixes
     */
    public Expression createExpression(Expression prefix, Iterator<ExpressionSuffix> it) {
      Expression exp = prefix;
      if (it.hasNext()) {
        exp = it.next().createExpression(prefix, it);
      } else {
        if (prefix instanceof CompileTimeExpression) {
          exp = ((CompileTimeExpression)prefix).createRuntimeExpression();
        }
      }
      return new ObjectFieldAccess(exp, identifier.image,
                                   SourceInfo.extend(exp, identifier.endLine, identifier.endColumn));
    }
  }
  
  class ArrayReferenceSuffix extends ExpressionSuffix implements SourceInfo.Wrapper {
    /**
     * The expression
     */
    public final Expression expression;
    
    public final SourceInfo sourceInfo;
    
    /**
     * Creates a new suffix
     * @param exp the expression
     * @param el  the end line
     * @param ec  the end column
     */
    public ArrayReferenceSuffix(Expression exp, SourceInfo si) {
      expression = exp;
      sourceInfo = si;
    }
    
    public SourceInfo getSourceInfo() { return sourceInfo; }
    
    /**
     * Creates an expression node
     * @param prefix the prefix expression
     * @param it     an iterator over the suffixes
     */
    public Expression createExpression(Expression prefix, Iterator<ExpressionSuffix> it) {
      Expression exp = prefix;
      if (it.hasNext()) {
        exp = it.next().createExpression(prefix, it);
      } else {
        if (prefix instanceof CompileTimeExpression) {
          exp = ((CompileTimeExpression)prefix).createRuntimeExpression();
        }
      }
      return new ArrayAccess(exp, expression, SourceInfo.span(exp, this));
    }
  }
  
  class DotThisSuffix extends ExpressionSuffix implements SourceInfo.Wrapper {
    public final SourceInfo sourceInfo;
    
    /**
     * Creates a new suffix
     * @param el  the end line
     * @param ec  the end column
     * @param fn  the file name
     */
    public DotThisSuffix(SourceInfo si) { sourceInfo = si; }
    
    public SourceInfo getSourceInfo() { return sourceInfo; }
    
    /**
     * Creates an expression node
     * @param prefix the prefix expression
     * @param it     an iterator over the suffixes
     */
    public Expression createExpression(Expression prefix, Iterator<ExpressionSuffix> it) {
      Expression exp = prefix;
      if (it.hasNext()) {
        exp = (it.next()).createExpression(prefix, it);
      } else {
        if (prefix instanceof CompileTimeExpression) {
          exp = ((CompileTimeExpression)prefix).createRuntimeExpression();
        }
      }
      if (exp instanceof AmbiguousName) {
        return new ThisExpression(((AmbiguousName)exp).getIdentifiers(), SourceInfo.span(exp, this));
      } else {
        throw new ParseError(reader.getMessage("this.prefix", null), exp.getSourceInfo());
      }
    }
  }
  
  class ArgumentsSuffix extends ExpressionSuffix implements SourceInfo.Wrapper {
    /**
     * The arguments
     */
    public List<Expression> arguments;
    
    /**
     * The type arguments
     */
    public List<TypeName> typeArgs;
    
    public final SourceInfo sourceInfo;
    
    /**
     * Creates a new argument suffix
     * @param args  the list of argument
     * @param el    the end line
     * @param ec    the end column
     */
    public ArgumentsSuffix(List<Expression> args, List<TypeName> tArgs, SourceInfo si) {
      arguments = args;
      typeArgs = tArgs;
      sourceInfo = si;
    }
    
    public SourceInfo getSourceInfo() { return sourceInfo; }
    
    /**
     * Creates an expression node
     * @param prefix the prefix expression
     * @param it     an iterator over the suffixes
     */
    public Expression createExpression(Expression prefix, Iterator<ExpressionSuffix> it) {
      if (it.hasNext()) {
        ExpressionSuffix es = it.next();
        if (es instanceof DotIdentifierSuffix) {
          DotIdentifierSuffix dis = (DotIdentifierSuffix)es;
          Expression exp = prefix;
          if (it.hasNext()) {
            exp = it.next().createExpression(prefix, it);
          } else if (prefix instanceof CompileTimeExpression) {
            exp = ((CompileTimeExpression)prefix).createRuntimeExpression();
          }
          if(typeArgs != null && typeArgs.size() > 0)
            return new PolymorphicObjectMethodCall(exp, dis.identifier.image, arguments, typeArgs,
                                                   SourceInfo.span(exp, this));
          else
            return new ObjectMethodCall(exp, dis.identifier.image, arguments, SourceInfo.span(exp, this));
        } else {
          throw new ParseError(reader.getMessage("parameter.list", null), sourceInfo);
        }
      } else {
        if (prefix instanceof CompileTimeQualifiedName) {
          // Remove the last identifier from the qualified name
          List<IdentifierToken>  l = ((CompileTimeQualifiedName)prefix).identifiers;
          IdentifierToken f = l.get(0);
          IdentifierToken t = l.remove(l.size()-1);
          if (l.size() >= 1) {
            Expression exp = ((CompileTimeQualifiedName)prefix).
              createRuntimeExpression();
            if(typeArgs != null && typeArgs.size() > 0)
              return new PolymorphicObjectMethodCall(exp, t.image(), arguments, typeArgs,
                                                     SourceInfo.span(f, this));
            else
              return new ObjectMethodCall(exp, t.image(), arguments, SourceInfo.span(f, this));
          }
          else {
            if (typeArgs != null && typeArgs.size() > 0) {
              throw new IllegalArgumentException("Type arguments on simple method not supported");
            }
            return new SimpleMethodCall(t.image(), arguments, SourceInfo.span(f, this)); 
          }
        } else if (prefix instanceof CompileTimeSuperExpression) {
          // Transform the super expression into a super method call
          CompileTimeSuperExpression se = (CompileTimeSuperExpression)prefix;
          if(typeArgs != null && typeArgs.size() > 0)
            return new PolymorphicSuperMethodCall(se.identifier, arguments, typeArgs, SourceInfo.span(se, this));
          else
            return new SuperMethodCall(se.identifier, arguments, SourceInfo.span(se, this));
        } else {
          throw new ParseError(reader.getMessage("parameter.list", null), sourceInfo);
        }
      }
    }
  }
  
  interface CompileTimeExpression {
    /**
     * Builds a runtime expression from this compile-time one.
     * This method must only be called when the expression has no suffix.
     */
    Expression createRuntimeExpression();
    
  }
  
  class CompileTimeSuperExpression
    extends Expression implements CompileTimeExpression {
    /**
     * The identifier from the superclass
     */
    public String identifier;
    
    /**
     * Initializes the expression
     * @param ident the identifier from the super class
     * @param bl    the begin line
     * @param bc    the begin column
     * @param el    the end line
     * @param ec    the end column
     */
    public CompileTimeSuperExpression(String ident, SourceInfo si) {
      super(si);
      identifier = ident;
    }
    
    /**
     * Builds a runtime expression from this compile-time one.
     * This method must be called when the expression has no suffix
     */
    public Expression createRuntimeExpression() {
      return new SuperFieldAccess(identifier, getSourceInfo());
    }
    
    /**
     * Not used
     */
    public <T> T acceptVisitor(Visitor<T> visitor) {
      return null;
    }
  }
  
  class CompileTimeQualifiedName extends Expression implements CompileTimeExpression {
    /**
     * The identifiers (tokens)
     */
    public List<IdentifierToken> identifiers;
    
    /**
     * Initializes the expression
     * @param ids a list of token
     */
    public CompileTimeQualifiedName(List<IdentifierToken> ids) {
      super(SourceInfo.NONE);
      identifiers = ids;
    }
    
    /**
     * Creates a runtime qualified name
     */
    public Expression createFieldAccess() {
      if (identifiers.size() == 1) {
        return new AmbiguousName(identifiers, identifiers.get(0).getSourceInfo());
      } else {
        IdentifierToken f = identifiers.get(0);
        IdentifierToken t = identifiers.remove(identifiers.size()-1);
        IdentifierToken l = identifiers.get(identifiers.size()-1);
        return new ObjectFieldAccess(new AmbiguousName(identifiers, SourceInfo.span(f, l)),
                                     t.image(), SourceInfo.span(f, t));
      }
    }
    
    /**
     * Builds a runtime expression from this compile-time one.
     * This method must be called when the expression has no suffix
     */
    public Expression createRuntimeExpression() {
      return new AmbiguousName(identifiers,
                               SourceInfo.span(identifiers.get(0), identifiers.get(identifiers.size()-1)));
    }
    
    /**
     * Not used
     */
    public <T> T acceptVisitor(Visitor<T> visitor) {
      return null;
    }
  }
  
  /**
   * To store modifier flags
   */
  class ModifierFlags implements SourceInfo.Wrapper {
    int accessFlags;
    SourceInfo sourceInfo;
    
    ModifierFlags(int flags, SourceInfo si) {
      accessFlags = flags;
      sourceInfo = si;
    }
    
    public SourceInfo getSourceInfo() { return sourceInfo; }
  }
  
  /**
   * To store a class body
   */
  static class ClassBody implements SourceInfo.Wrapper {
    List<Node> list;
    SourceInfo sourceInfo;
    
    ClassBody(List<Node> l, SourceInfo si) {
      list = l;
      sourceInfo = si;
    }
    
    public SourceInfo getSourceInfo() { return sourceInfo; }
  }
}
PARSER_END(Parser)
  
  /*
   * The lexical grammar
   */
  
  /* WHITE SPACE */
  
  SKIP :
{
  " "
    | "\t"
    | "\n"
    | "\r"
    | "\f"
}

/* COMMENTS */

  SKIP :
  {
    "//" : IN_SINGLE_LINE_COMMENT
      |
    "#" : IN_SINGLE_LINE_COMMENT
      |
    <"/**" ~["/"]> { input_stream.backup(1); } : IN_FORMAL_COMMENT
      |
    "/*" : IN_MULTI_LINE_COMMENT
  }
  
  <IN_SINGLE_LINE_COMMENT>
  SKIP :
  {
    <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
  }
  
  <IN_FORMAL_COMMENT>
  SKIP :
  {
    <FORMAL_COMMENT: "*/" > : DEFAULT
  }
  
  <IN_MULTI_LINE_COMMENT>
  SKIP :
  {
    <MULTI_LINE_COMMENT: "*/" > : DEFAULT
  }
  
  <IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
  SKIP :
  {
    < ~[] >
  }
  
  /* RESERVED WORDS AND LITERALS */
  
  TOKEN :
  {
    < ABSTRACT: "abstract" >
    | < ASSERT: "assert" >
    | < BOOLEAN: "boolean" >
    | < BREAK: "break" >
    | < BYTE: "byte" >
    | < CASE: "case" >
    | < CATCH: "catch" >
    | < CHAR: "char" >
    | < CLASS: "class" >
    | < CONST: "const" >
    | < CONTINUE: "continue" >
    | < _DEFAULT: "default" >
    | < DO: "do" >
    | < DOUBLE: "double" >
    | < ELSE: "else" >
    | < ENUM: "enum" >
    | < EXTENDS: "extends" >
    | < FALSE: "false" >
    | < FINAL: "final" >
    | < FINALLY: "finally" >
    | < FLOAT: "float" >
    | < FOR: "for" >
    | < GOTO: "goto" >
    | < IF: "if" >
    | < IMPLEMENTS: "implements" >
    | < IMPORT: "import" >
    | < INSTANCEOF: "instanceof" >
    | < INT: "int" >
    | < INTERFACE: "interface" >
    | < LONG: "long" >
    | < NATIVE: "native" >
    | < NEW: "new" >
    | < NULL: "null" >
    | < PACKAGE: "package">
    | < PRIVATE: "private" >
    | < PROTECTED: "protected" >
    | < PUBLIC: "public" >
    | < RETURN: "return" >
    | < SHORT: "short" >
    | < STATIC: "static" >
    | < SUPER: "super" >
    | < SWITCH: "switch" >
    | < SYNCHRONIZED: "synchronized" >
    | < THIS: "this" >
    | < THROW: "throw" >
    | < THROWS: "throws" >
    | < TRANSIENT: "transient" >
    | < TRUE: "true" >
    | < TRY: "try" >
    | < VOID: "void" >
    | < VOLATILE: "volatile" >
    | < WHILE: "while" >
  }
  
  /* LITERALS */
  
  TOKEN :
  {
    < INTEGER_LITERAL:
      <DECIMAL_LITERAL>
      | <HEX_LITERAL>
      | <OCTAL_LITERAL>
      >
      |
    < LONG_LITERAL:
      <DECIMAL_LITERAL> ["l","L"]
      | <HEX_LITERAL>     ["l","L"]
      | <OCTAL_LITERAL>   ["l","L"]
      >
      |
    < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
      |
    < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
      |
    < #OCTAL_LITERAL: "0" (["0"-"7"])* >
      |
    < FLOAT_LITERAL:
      (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? ["f","F"]
      | "." (["0"-"9"])+ (<EXPONENT>)? ["f","F"]
      | (["0"-"9"])+ <EXPONENT> ["f","F"]
      | (["0"-"9"])+ (<EXPONENT>)? ["f","F"]
      >
      |
      < DOUBLE_LITERAL:
      (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["d","D"])?
      | "." (["0"-"9"])+ (<EXPONENT>)? (["d","D"])?
      | (["0"-"9"])+ <EXPONENT> (["d","D"])?
      | (["0"-"9"])+ (<EXPONENT>)? ["d","D"]
      >
      |
      < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
      |
      < CHARACTER_LITERAL:
      "'"
      (   (~["'","\\","\n","\r"])
         | ("\\"
              ( ["n","t","b","r","f","\\","'","\""]
                 | ["0"-"7"] ( ["0"-"7"] )?
                 | ["0"-"3"] ["0"-"7"] ["0"-"7"]
                 )
              )
         )
      "'"
      >
      |
      < STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
         | ("\\"
              ( ["n","t","b","r","f","\\","'","\""]
                 | ["0"-"7"] ( ["0"-"7"] )?
                 | ["0"-"3"] ["0"-"7"] ["0"-"7"]
                 )
              )
         )*
      "\""
      >
  }
  
  /* IDENTIFIERS */
  
  TOKEN :
  {
    < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >
      |
    < #LETTER:
      [
       "\u0024",
       "\u0041"-"\u005a",
       "\u005f",
       "\u0061"-"\u007a",
       "\u00c0"-"\u00d6",
       "\u00d8"-"\u00f6",
       "\u00f8"-"\u00ff",
       "\u0100"-"\u1fff",
       "\u3040"-"\u318f",
       "\u3300"-"\u337f",
       "\u3400"-"\u3d2d",
       "\u4e00"-"\u9fff",
       "\uf900"-"\ufaff"
         ]
      >
      |
    < #DIGIT:
      [
       "\u0030"-"\u0039",
       "\u0660"-"\u0669",
       "\u06f0"-"\u06f9",
       "\u0966"-"\u096f",
       "\u09e6"-"\u09ef",
       "\u0a66"-"\u0a6f",
       "\u0ae6"-"\u0aef",
       "\u0b66"-"\u0b6f",
       "\u0be7"-"\u0bef",
       "\u0c66"-"\u0c6f",
       "\u0ce6"-"\u0cef",
       "\u0d66"-"\u0d6f",
       "\u0e50"-"\u0e59",
       "\u0ed0"-"\u0ed9",
       "\u1040"-"\u1049"
         ]
      >
  }
  
  /* SEPARATORS */
  
  TOKEN :
  {
    < LPAREN: "(" >
    | < RPAREN: ")" >
    | < LBRACE: "{" >
    | < RBRACE: "}" >
    | < LBRACKET: "[" >
    | < RBRACKET: "]" >
    | < SEMICOLON: ";" >
    | < COMMA: "," >
    | < DOT: "." >
  }
  
  /* OPERATORS */
  
  TOKEN :
  {
    < ASSIGN: "=" >
    | < GREATER_THAN: ">" >
    | < LESS: "<" >
    | < BANG: "!" >
    | < TILDE: "~" >
    | < HOOK: "?" >
    | < COLON: ":" >
    | < EQUAL: "==" >
    | < LESS_OR_EQUAL: "<=" >
    | < GREATER_OR_EQUAL: ">=" >
    | < NOT_EQUAL: "!=" >
    | < CONDITIONAL_OR: "||" >
    | < CONDITIONAL_AND: "&&" >
    | < INCREMENT: "++" >
    | < DECREMENT: "--" >
    | < PLUS: "+" >
    | < MINUS: "-" >
    | < STAR: "*" >
    | < SLASH: "/" >
    | < BITWISE_AND: "&" >
    | < BITWISE_OR: "|" >
    | < XOR: "^" >
    | < REMAINDER: "%" >
    | < LEFT_SHIFT: "<<" >
      /* | < RIGHT_SIGNED_SHIFT: ">>" >
       | < RIGHT_UNSIGNED_SHIFT: ">>>" > */
    | < PLUS_ASSIGN: "+=" >
    | < MINUS_ASSIGN: "-=" >
    | < STAR_ASSIGN: "*=" >
    | < SLASH_ASSIGN: "/=" >
    | < AND_ASSIGN: "&=" >
    | < OR_ASSIGN: "|=" >
    | < XOR_ASSIGN: "^=" >
    | < REMAINDER_ASSIGN: "%=" >
    | < LEFT_SHIFT_ASSIGN: "<<=" >
    | < RIGHT_SIGNED_SHIFT_ASSIGN: ">>=" >
    | < RIGHT_UNSIGNED_SHIFTASSIGN: ">>>=" >
    | < VAR_ARGS:  "...">
  }
  
  TOKEN : /* OPERATORS, from Generics Preprocessor  */
  {
    /*  < ASSIGN: "=" >
     | < GT: ">" >
     | < LT: "<" >
     | < BANG: "!" >
     | < TILDE: "~" >
     | < HOOK: "?" >
     | < COLON: ":" >
     | < EQ: "==" >
     | < LE: "<=" >
     | < GE: ">=" >
     | < NE: "!=" >
     | < SC_OR: "||" >
     | < SC_AND: "&&" >
     | < INCR: "++" >
     | < DECR: "--" >
     | < PLUS: "+" >
     | < MINUS: "-" >
     | < STAR: "*" >
     | < SLASH: "/" >
     | < BIT_AND: "&" >
     | < BIT_OR: "|" >
     | < XOR: "^" >
     | < REM: "%" >
     | < LSHIFT: "<<" >
     | */
    < RSIGNEDSHIFT: ">>" >
    {
      matchedToken.kind = RSSHIFT1;
      matchedToken.image = ">@1";
      matchedToken.next = new Token();
      matchedToken.next.kind = RSSHIFT2;
      matchedToken.next.image = ">@2";
    }
    | < RUNSIGNEDSHIFT: ">>>" >
    {
      matchedToken.image = ">`1";
      matchedToken.kind = RUSHIFT1;
      matchedToken.next = new Token();
      matchedToken.next.kind = RUSHIFT2;
      matchedToken.next.image = ">`2";
      matchedToken.next.next = new Token();
      matchedToken.next.next.kind = RUSHIFT3;
      matchedToken.next.next.image = ">`3";
    }
    | < RSSHIFT1: ">@1" >
    | < RSSHIFT2: ">@2" >
    | < RUSHIFT1: ">`1" >
    | < RUSHIFT2: ">`2" >
    | < RUSHIFT3: ">`3" >
      /*| < PLUSASSIGN: "+=" >
       | < MINUSASSIGN: "-=" >
       | < STARASSIGN: "*=" >
       | < SLASHASSIGN: "/=" >
       | < ANDASSIGN: "&=" >
       | < ORASSIGN: "|=" >
       | < XORASSIGN: "^=" >
       | < REMASSIGN: "%=" >
       | < LSHIFTASSIGN: "<<=" >
       | < RSIGNEDSHIFTASSIGN: ">>=" >
       | < RUNSIGNEDSHIFTASSIGN: ">>>=" >*/
  }
  
  JAVACODE
    void _errorChar(char c) {
    _throwParseException("'" + c + "' expected.");
  }
  /*
   * The syntactic grammar
   */
  
  // Productions for the intepreter ////////////////////////////////////////////////
  
  /**
   * Parses input stream. This production is
   * not a Java language rule. It is used by DynamicJava.
   * @return a list of nodes (possibly empty)
   * @see koala.dynamicjava.tree.Node
   */
  List<Node> parseStream() :
  { List<Node> list = new LinkedList<Node>(); List<Node> ns; }
  {
    try {
      (  ns = topLevelStatement() { list.addAll(ns); } )* <EOF>
      { return list; }
    }
    catch(ParseException pe) {
      _throwParseException(pe, "Invalid top level statement");
    }
  }
  
  /**
   * Parses an item of the input stream. This production is
   * not a Java language rule. It is used by DynamicJava.
   * @return a list of nodes (a list because a single variable declaration
   * can be parsed to multiple VariableDeclaration nodes)
   * @see koala.dynamicjava.tree.Node
   */
  List<Node> topLevelStatement() :
  { Node node = null; List<Node> nodes = null; }
  {
    try {
      (
          node = packageDeclaration()
        | node = importDeclaration()
        | LOOKAHEAD(methodDeclarationLookahead()) node = methodDeclaration()
        | LOOKAHEAD(variableDeclarationLookahead()) nodes = localVariableDeclaration(false)
        | LOOKAHEAD(typeDeclarationLookahead()) node = typeDeclaration()
        | node = statement(false)
      )
      { return (node != null) ? Collections.singletonList(node) : nodes; }
    }
    catch(ParseException pe) {
      _throwParseException(pe, "Invalid top level statement");
    }
  }
  

  // Productions for Packages ////////////////////////////////////////////////////////
  
  /**
   * Parses a Java compilation unit
   * @return a list of nodes (possibly empty)
   * @see koala.dynamicjava.tree.Node
   */
  List<Node> parseCompilationUnit() :
  {
    List<Node> list = new LinkedList<Node>();
    Node node;
  }
  {
    [ node=packageDeclaration()
       {
      list.add(node);
    }
     ]
       ( node=importDeclaration()
          {
       list.add(node);
     }
     )*
       ( ( node=typeDeclaration()
            {
       list.add(node);
     }
          | ";" )
          )*
            <EOF>
          {
            return list;
          }
  }
  
  /**
   * Parses a package declaration
   * @see koala.dynamicjava.tree.PackageDeclaration
   */
  PackageDeclaration packageDeclaration() :
  {
    ReferenceTypeName name = null;
    Token t1, t2;
  }
  {
    try {
      t1="package" [ name=ReferenceTypeName() ] (t2=";" | t2=<EOF>)
      {
        if(name instanceof GenericReferenceTypeName){
          _throwParseException("Package names cannot be parameterized.");
        }
        if(name == null) {
          _throwParseException("Empty Package name");
        }
        return new PackageDeclaration(name.getRepresentation(), _range(t1, t2));
      }
    }
    catch(ParseException pe) {
      _throwParseException(pe,"Invalid Package Declaration");
    }
  }
  
  /**
   * Parses an import declaration
   * @see koala.dynamicjava.tree.ImportDeclaration
   */
  ImportDeclaration importDeclaration() :
  {
    ReferenceTypeName name = null;
    Token star = null;
    Token t1, t2;
    Token sttic = null;
  }
  {
    try {
      t1="import" [sttic="static"] [name=ReferenceTypeName()] ["." star="*"] (t2=";" | t2=<EOF>)
      {
        if(name instanceof GenericReferenceTypeName){
          _throwParseException("Import names cannot be parameterized.");
        }
        if(name == null) {
          _throwParseException("Missing name - Cannot import");
        }
        return new ImportDeclaration(name.getRepresentation(), star != null, sttic != null, _range(t1, t2));
      }
    }
    catch(ParseException pe) {
      _throwParseException(pe,"Invalid Import Declaration");
    }
  }
  
  /**
   * Parses a top level type declaration
   * @see koala.dynamicjava.tree.TypeDeclaration
   */
  TypeDeclaration typeDeclaration() :
  {
    TypeDeclaration node;
    int modifiers;
  }
  {
    try {
      (    LOOKAHEAD(classDeclarationLookahead())
         node=classDeclaration()
         | LOOKAHEAD(enumDeclarationLookahead())
         node=enumDeclaration()
         | LOOKAHEAD(interfaceDeclarationLookahead())
         node=interfaceDeclaration()
         )
      {
        //Handles modifiers not allowed at the top level
        checkModifiers(node.getAccessFlags(), Modifier.STATIC | Modifier.PRIVATE | Modifier.PROTECTED);
        return node;
      }
    }
    catch(ParseException pe) {
      _throwParseException(pe,"invalid declaration");
    }
  }
  
  // Productions for Names ////////////////////////////////////////////////////////
  
  /**
   * Parses a name
   * @return a list of tree token
   * @see koala.dynamicjava.parser.wrapper.TreeToken
   */
  List<IdentifierToken> name() :
  {
    Token id;
    List<IdentifierToken>  list = new LinkedList<IdentifierToken>();
  }
  {
    id=<IDENTIFIER>
    {
      list.add(new TreeToken(id, file));
    }
    ( LOOKAHEAD(2)
       "." id=<IDENTIFIER>
     {
      list.add(new TreeToken(id, file));
    }
    )*
    {
      return list;
    }
  }
  
  // Production for a ReferenceTypeName ////////////////////////////////////////////////////////
  ReferenceTypeName ReferenceTypeName() :
  {
    Token id = null;
    List<IdentifierToken> list = new LinkedList<IdentifierToken>();
    List<TypeName> typeArgs = new LinkedList<TypeName>();
    List<List<? extends TypeName>> allTypeArgs = new LinkedList<List<? extends TypeName>>();
  }
  {
    try{
      id=<IDENTIFIER> [LOOKAHEAD(TypeArguments()) typeArgs = TypeArguments() ]
      {
        list.add(new TreeToken(id, file));
        allTypeArgs.add( typeArgs );
        typeArgs = new LinkedList<TypeName>();
      }
      ( LOOKAHEAD("." <IDENTIFIER>) "." id=<IDENTIFIER>  [LOOKAHEAD(TypeArguments()) typeArgs = TypeArguments() ]
         {
        list.add(new TreeToken(id, file));
        allTypeArgs.add( typeArgs );
        typeArgs = new LinkedList<TypeName>();
      }
      )*
        
      {
        IdentifierToken f  = list.get(0);
        IdentifierToken l  = list.get(list.size()-1);
        boolean Parameterized = false;
        for( int i = 0; i < allTypeArgs.size(); i++ ){
          List<? extends TypeName> targs = allTypeArgs.get(i);
          if(targs.size() > 0) {
            Parameterized = true;
            break;
          }
        }
        if(!Parameterized){
          if(TypeParamsMap.containsKey(TreeUtilities.listToName(list))){
            return TypeParamsMap.get(TreeUtilities.listToName(list));
          } else if(GenericTypesEnv.contains(TreeUtilities.listToName(list))){
            return GenericTypesEnv.lookup(TreeUtilities.listToName(list));
          } else {
            return new ReferenceTypeName(list, SourceInfo.span(f, l));
          }
        } else {
          return new GenericReferenceTypeName(list, allTypeArgs, SourceInfo.span(f, l));
        }
      }
    }
    catch(ParseException pe) {
      _throwParseException(pe,"Invalid Reference name");
    }
  }
  
  /**
   * Parses a comma separated list of ReferenceTypeName names
   * @return a list of ReferenceTypeName
   * @see koala.dynamicjava.tree.ReferenceTypeName
   */
  List<? extends ReferenceTypeName> ReferenceTypeNameList() :
  {
    List<ReferenceTypeName> list = new LinkedList<ReferenceTypeName>();
    ReferenceTypeName obj;
  }
  {
    obj=ReferenceTypeName()
    {
      list.add(obj);
    }
    ( "," obj=ReferenceTypeName()
       {
      list.add(obj);
    }
    )*
    {
      return list;
    }
  }
  
  // Productions for Classes //////////////////////////////////////////////////////
  
  // Productions for Class Declaration ============================================
  
  /**
   * Parses a class declaration
   * @see koala.dynamicjava.tree.ClassDeclaration
   */
  ClassDeclaration classDeclaration() :
  {
    ClassDeclaration cd;
    ModifierFlags    md;
  }
  {
    md=modifiers() cd=unmodifiedClassDeclaration(md)
    {
      if(md != null)
        checkModifiers(md.accessFlags, Modifier.NATIVE | Modifier.SYNCHRONIZED | Modifier.TRANSIENT | Modifier.VOLATILE);
      return cd;
    }
  }
  
  /**
   * Used internally to parse a modifier
   */
  ModifierFlags modifiers() :
  {
    Token t = null;
    int flags = 0;
    Token ft = null;
  }
  {
    ( t="abstract"
       {
      if (ft == null) {
        ft = t;
      } else if ((flags & Modifier.ABSTRACT) != 0) {
        throw new ParseError(reader.getMessage("abstract.abstract", null), _range(t, t));
      } else if ((flags & Modifier.FINAL) != 0) {
        throw new ParseError(reader.getMessage("abstract.final", null), _range(t, t));
      }
      flags |= Modifier.ABSTRACT;
    }
     | t="final"
       {
       if (ft == null) {
         ft = t;
       } else if ((flags & Modifier.FINAL) != 0) {
         throw new ParseError(reader.getMessage("final.final", null), _range(t, t));
       } else if ((flags & Modifier.ABSTRACT) != 0) {
         throw new ParseError(reader.getMessage("abstract.final", null), _range(t, t));
       }
       flags |= Modifier.FINAL;
     }
     | t="public"
       {
       if (ft == null) {
         ft = t;
       } else if ((flags & Modifier.PUBLIC) != 0) {
         throw new ParseError(reader.getMessage("public.public", null), _range(t, t));
       } else if ((flags & Modifier.PROTECTED) != 0) {
         throw new ParseError(reader.getMessage("public.protected", null), _range(t, t));
       } else if ((flags & Modifier.PRIVATE) != 0) {
         throw new ParseError(reader.getMessage("public.private", null), _range(t, t));
       }
       
       flags |= Modifier.PUBLIC;
     }
     | t="protected"
       {
       if (ft == null) {
         ft = t;
       } else if ((flags & Modifier.PROTECTED) != 0) {
         throw new ParseError(reader.getMessage("protected.protected", null), _range(t, t));
       } else if ((flags & Modifier.PUBLIC) != 0) {
         throw new ParseError(reader.getMessage("public.protected", null), _range(t, t));
       } else if ((flags & Modifier.PRIVATE) != 0) {
         throw new ParseError(reader.getMessage("protected.private", null), _range(t, t));
       }
       flags |= Modifier.PROTECTED;
     }
     | t="private"
       {
       if (ft == null) {
         ft = t;
       }  else if ((flags & Modifier.PRIVATE) != 0) {
         throw new ParseError(reader.getMessage("private.private", null), _range(t, t));
       } else if ((flags & Modifier.PUBLIC) != 0) {
         throw new ParseError(reader.getMessage("public.private", null), _range(t, t));
       } else if ((flags & Modifier.PROTECTED) != 0) {
         throw new ParseError(reader.getMessage("protected.private", null), _range(t, t));
       }
       flags |= Modifier.PRIVATE;
     }
     | t="transient"
       {
       if (ft == null) {
         ft = t;
       } else if ((flags & Modifier.TRANSIENT) != 0) {
         throw new ParseError(reader.getMessage("transient.transient", null), _range(t, t));
       }
       flags |= Modifier.TRANSIENT;
     }
     | t="volatile"
       {
       if (ft == null) {
         ft = t;
       } else if ((flags & Modifier.VOLATILE) != 0) {
         throw new ParseError(reader.getMessage("volatile.volatile", null), _range(t, t));
       }
       flags |= Modifier.VOLATILE;
     }
     | t="native"
       {
       if (ft == null) {
         ft = t;
       } else if ((flags & Modifier.NATIVE) != 0) {
         throw new ParseError(reader.getMessage("native.native", null), _range(t, t));
       }  else if ((flags & Modifier.ABSTRACT) != 0) {
         throw new ParseError(reader.getMessage("abstract.native", null), _range(t, t));
       }
       flags |= Modifier.NATIVE;
     }
     | t="static"
       {
       if (ft == null) {
         ft = t;
       } else if ((flags & Modifier.STATIC) != 0) {
         throw new ParseError(reader.getMessage("static.static", null), _range(t, t));
       }
       flags |= Modifier.STATIC;
     }
     | t="synchronized"
       {
       if (ft == null) {
         ft = t;
       } else if ((flags & Modifier.SYNCHRONIZED) != 0) {
         throw new ParseError(reader.getMessage("synchronized.synchronized", null), _range(t, t));
       }
       flags |= Modifier.SYNCHRONIZED;
     }
     )*
     {
       return (ft == null)
         ? null
         : new ModifierFlags(flags, _range(ft, t));
     }
  }
  
  /**
   * Parses a class declaration without modifier
   * @see koala.dynamicjava.tree.ClassDeclaration
   */
  ClassDeclaration unmodifiedClassDeclaration(ModifierFlags mf) :
  {
    Token t;
    Token id;
    TypeParameter[] typeParameters = null;
    ReferenceTypeName  ext  = null;
    List<? extends ReferenceTypeName> impl = null;
    ClassBody body;
  }
  {
    t="class" id=<IDENTIFIER>
      [ typeParameters = TypeParameters() ]
      [ "extends" ext=ReferenceTypeName() ] [ "implements" impl=ReferenceTypeNameList() ]
      body=classBody()
    {
      if (typeParameters != null) {
        GenericTypesEnv = GenericTypesEnv.getRest(); // pop added type params
        if (mf == null) {
          return new GenericClassDeclaration(0, id.image, ext, impl, body.list, typeParameters,
                                             SourceInfo.prepend(t.beginLine, t.beginColumn, body));
        } else {
          return new GenericClassDeclaration(mf.accessFlags, id.image, ext, impl, body.list, typeParameters,
                                             SourceInfo.span(mf, body));
        }
      }
      else {
        if (mf == null) {
          return new ClassDeclaration(0, id.image, ext, impl, body.list,
                                      SourceInfo.prepend(t.beginLine, t.beginColumn, body));
        } else {
          return new ClassDeclaration(mf.accessFlags, id.image, ext, impl, body.list,
                                      SourceInfo.span(mf, body));
        }
      }
    }
  }
  
  /**
   * Used internally to parse the body of a class
   */
  ClassBody classBody() :
  {
    Token left, right;
    List<Node> list = new LinkedList<Node>();
    List<Node> decl;
  }
  {
    try {
      left = "{"
        (
         decl=classBodyDeclaration()
           {
        list.addAll(decl);
      }
      )*
      right ="}"
      {
        return new ClassBody(list, _range(left, right));
      }
    }
    catch (ParseException pe) {
      _throwParseException(pe,"Invalid class body");
    }
  }
  
  /**
   * Parses one declaration in the body of a class.
   * @return a list of node because one field declaration can
   *         contain multiple declarations.
   * @see koala.dynamicjava.tree.Node
   */
  List<Node> classBodyDeclaration() :
  {
    Node node = null;
    List<Node> list = new LinkedList<Node>();
  }
  {
    try {
      ( LOOKAHEAD(2)
         node=initializer()
         |
       LOOKAHEAD( classDeclarationLookahead())
         node=classDeclaration()
         |
       LOOKAHEAD( enumDeclarationLookahead())
         node=enumDeclaration()
         |
       LOOKAHEAD( interfaceDeclarationLookahead() )
         node=interfaceDeclaration()
         |
       LOOKAHEAD( constructorDeclarationLookahead() )
         node=constructorDeclaration()
         |
       LOOKAHEAD( methodDeclarationLookahead() )
         node=methodDeclaration()
         |
       list=fieldDeclaration()
         |
       ";"
         )
      {
        if (node != null) {
          list.add(node);
        }
        return list;
      }
    }
    catch (ParseException pe) {
      _throwParseException(pe,"Invalid Member Declaration");
    }
  }
  
  
  // Productions for Field Declaration ============================================
  
  /**
   * Parses a field declaration.
   * @return a list of field declaration because one field declaration can
   *         contain multiple declarations.
   * @see koala.dynamicjava.tree.FieldDeclaration
   */
  List<Node> fieldDeclaration() :
  {
    ModifierFlags mf;
    TypeName          typ;
    Token         id;
    int           dim  = 0;
    Expression    exp  = null;
    List<Node>    list = new LinkedList<Node>();
  }
  {
    try
    {
      mf=modifiers()
        typ=type() id=<IDENTIFIER>
        ( "[" "]" { dim++; } )*
          [ "=" exp=variableInitializer() ]
        {
          if(mf != null)
            checkModifiers(mf.accessFlags,Modifier.ABSTRACT | Modifier.NATIVE | Modifier.SYNCHRONIZED);
          list.add(createFieldDeclaration(mf, typ, id, exp, dim));
        }
        ( "," { dim = 0; exp = null; }
         id=<IDENTIFIER>
         ( "[" "]" { dim++; } )*
         [ "=" exp=variableInitializer() ]
           {
           list.add(createFieldDeclaration(mf, typ, id, exp, dim));
         }
         )* ";"
         {
           return list;
         }
    }
    catch (ParseException pe){
      _throwParseException(pe, "Invalid Field Declaration");
    }
    
  }
  
  // Productions for Method Declaration ===========================================
  
  /**
   * Parses a method declaration
   * @see koala.dynamicjava.tree.MethodDeclaration
   */
  MethodDeclaration methodDeclaration() :
  {
    MethodDeclaration md;
    ModifierFlags     mf;
    SourceInfo        si;
    int               flags = 0;
    TypeParameter[]   typeParameters = null;
    TypeName              typ;
    Token             id;
    int               dim = 0;
    List<FormalParameter> params;
    List<? extends ReferenceTypeName> exceptions = new LinkedList<ReferenceTypeName>();
    Node              body = null;
  }
  {
    try {
      mf=modifiers()
        [ typeParameters = TypeParameters() ]
        typ=resultType()
        id=<IDENTIFIER>
        params=formalParameters()
        ( "[" "]" { dim++; } )*
          [ "throws" exceptions=ReferenceTypeNameList() ]
          ( body=block() | body=emptyStatement() )
        {
          if (mf != null) {
            checkModifiers(mf.accessFlags, Modifier.TRANSIENT | Modifier.VOLATILE);
            si = mf.getSourceInfo();
            flags = mf.accessFlags;
          } else {
            si = typ.getSourceInfo();
          }
          if (dim > 0) {
            typ = new ArrayTypeName(typ, dim, false, typ.getSourceInfo());
          }
          if(lastFormalParameterIsVarArgs) flags |= 0x00000080; // java.lang.reflect.Modifier.VARARGS == 0x00000080
          
          if (typeParameters == null){
            return new MethodDeclaration(flags, typ, id.image, params,
                                         exceptions,
                                         (body instanceof BlockStatement) ?
                                           (BlockStatement)body : null,
                                         SourceInfo.span(si, body));
          } else {
            GenericTypesEnv = GenericTypesEnv.getRest(); // pop added type params
            return new PolymorphicMethodDeclaration(flags, typ, id.image, params,
                                                    exceptions,
                                                    (body instanceof BlockStatement) ?
                                                      (BlockStatement)body : null,
                                                    typeParameters,
                                                    SourceInfo.span(si, body));
          }
        }
    }
    catch(ParseException pe) {
      _throwParseException(pe, "Invalid method declaration");
    }
  }
  
  /**
   * Parses formal parameters of the form '(param, param, ...)'
   * @see koala.dynamicjava.tree.FormalParameter
   */
  List<FormalParameter> formalParameters() :
  {
    List<FormalParameter> list = new LinkedList<FormalParameter>();
    FormalParameter node;
    FormalParameter lastParam = null;
  }
  {
    try
    {
      "("
        
        [  
         ( LOOKAHEAD(formalParameterLookahead() ",")  node=formalParameter() "," {
        list.add(node);
      }
      )*   
         (LOOKAHEAD(varArgsFormalParameterLookahead() ")") lastParam = varArgsFormalParameter() 
            { lastFormalParameterIsVarArgs = true; } | 
          LOOKAHEAD(formalParameterLookahead() ")") lastParam = formalParameter()
            { lastFormalParameterIsVarArgs = false; } )
           ] ")"
            {
              if(lastParam != null) {
                list.add(lastParam);
              }
              return list;
            }
    }
    catch(ParseException pe) {
      _throwParseException(pe, "Invalid formal parameters");
    }
  }
  
  /**
   * Parses one formal parameter
   * @see koala.dynamicjava.tree.FormalParameter
   */
  FormalParameter formalParameter() :
  {
    TypeName  typ;
    Token id;
    Token f   = null;
    int   dim = 0;
  }
  {
    try
    {
      [ f="final" ] typ=type() id=<IDENTIFIER> ( "[" "]" { dim++; } )*
      {
        if (dim > 0) {
          typ = new ArrayTypeName(typ, dim, false, typ.getSourceInfo());
        }
        SourceInfo si;
        if (f == null) { si = SourceInfo.extend(typ, id.endLine, id.endColumn); }
        else { si = _range(f, id); }
        return new FormalParameter(f != null, typ, id.image, si);
      }
    }
    catch(ParseException pe) {
      _throwParseException(pe, "Invalid formal parameter");
    }
  }
  
  /**
   * Parses a varargs formal parameter
   * @see koala.dynamicjava.tree.FormalParameter
   */
  FormalParameter varArgsFormalParameter() :
  {
    TypeName  typ;
    Token id;
    Token f   = null;
  }
  {
    try
    {
      [ f="final" ] typ=type() <VAR_ARGS> id=<IDENTIFIER>
      {
        // convert the type of the formal parameter to be an array
        typ = new ArrayTypeName(typ, 1, true, typ.getSourceInfo());
        SourceInfo si;
        if (f == null) { si = SourceInfo.extend(typ, id.endLine, id.endColumn); }
        else { si = _range(f, id); }
        return new FormalParameter(f != null, typ, id.image, si);
      }
    }
    catch(ParseException pe) {
      _throwParseException(pe, "Invalid varargs formal parameter");
    }
  }
  
  
  // Production for Initializer ===================================================
  
  /**
   * Parses one initializer
   * @see koala.dynamicjava.tree.Initializer
   */
  Initializer initializer() :
  {
    Token t = null;
    BlockStatement node;
  }
  {
    [ t="static" ] node=block()
    {
      if (t == null) {
        return new InstanceInitializer(node, node.getSourceInfo());
      } else {
        return new ClassInitializer(node, SourceInfo.prepend(t.beginLine, t.beginColumn, node));
      }
    }
  }
  
  // Productions for Constructor Declaration ======================================
  
  /**
   * Parses a constructor declaration
   * @see koala.dynamicjava.tree.ConstructorDeclaration
   */
  ConstructorDeclaration constructorDeclaration() :
  {
    ModifierFlags         mf;
    int                   flags = 0;
    Token                 id;
    TypeParameter[]   typeParameters = null;
    List<FormalParameter> params;
    List<? extends ReferenceTypeName> exceptions = new LinkedList<ReferenceTypeName>();
    ConstructorCall ci = null;
    List<Node>            stmt;
    List<Node>            stmts = new LinkedList<Node>();
    SourceInfo            si;
    Token                 e;
  }
  {
    try
    {
      mf = modifiers()
        [ typeParameters = TypeParameters() ]
        id=<IDENTIFIER>
        params=formalParameters()
        [ "throws" exceptions=ReferenceTypeNameList() ]
        "{"
        [ LOOKAHEAD( explicitConstructorCallLookahead() )
           ci=explicitConstructorCall() ]
        ( stmt=blockStatement()
           {
        stmts.addAll(stmt);
      }
      )*
        e="}"
      {
        if (mf !=null) {
          //Modifiers not allowed in a constructor declaration
          checkModifiers(mf.accessFlags, Modifier.STATIC | Modifier.FINAL | Modifier.NATIVE | Modifier.ABSTRACT
                           | Modifier.SYNCHRONIZED | Modifier.TRANSIENT | Modifier.VOLATILE);
          flags = mf.accessFlags;
          si = mf.getSourceInfo();
        }
        else if (typeParameters != null && typeParameters.length > 0) {
          si = typeParameters[0].getSourceInfo();
        }
        else {
          si = _range(id, id);
        }
        if(lastFormalParameterIsVarArgs) flags |= 0x00000080; // Modifier.VARARGS == 0x00000080
        if (typeParameters == null) {
          return new ConstructorDeclaration(flags, id.image, params, exceptions, ci, stmts,
                                            SourceInfo.extend(si, e.endLine, e.endColumn));
        } else {
          GenericTypesEnv = GenericTypesEnv.getRest(); // pop added type params
          return new PolymorphicConstructorDeclaration(flags, id.image, params,
                                                       exceptions, ci, stmts, typeParameters,
                                                       SourceInfo.extend(si, e.endLine, e.endColumn));
        }
      }
    }
    catch(ParseException pe) {
      _throwParseException(pe, "Invalid constructor declaration");
    }
  }
  
  /**
   * Parses a constructor invocation
   * @see koala.dynamicjava.tree.ConstructorCall
   */
  ConstructorCall explicitConstructorCall() :
  {
    Token           b, e;
    ArgumentsSuffix args;
    Expression      exp = null;
    List<TypeName> typeArgs = new LinkedList<TypeName>();
  }
  {
    try
    {
      ( LOOKAHEAD([TypeArguments()] "this" arguments(typeArgs) ";")
         [ typeArgs = TypeArguments() ]
         b="this" args=arguments(typeArgs) e=";"
         |
       [ LOOKAHEAD(2) exp=primaryExpression() "." ]
         [LOOKAHEAD(TypeArguments()) typeArgs = TypeArguments()]
         b="super" args=arguments(typeArgs) e=";"
         )
      {
        return new ConstructorCall(exp, args.arguments, b.image.equals("super"), _range(b, e));
      }
    }
    catch(ParseException pe) {
      _throwParseException(pe, "Invalid constructor invocation");
    }
  }
  
  // Productions for Interfaces ///////////////////////////////////////////////////
  
  /**
   * Parses a interface declaration
   * @see koala.dynamicjava.tree.InterfaceDeclaration
   */
  InterfaceDeclaration interfaceDeclaration() :
  {
    InterfaceDeclaration id;
    ModifierFlags        md;
  }
  {
    md=modifiers() id=unmodifiedInterfaceDeclaration(md)
    {
      if(md != null) {
        checkModifiers(md.accessFlags, Modifier.FINAL | Modifier.NATIVE | Modifier.SYNCHRONIZED | Modifier.TRANSIENT | Modifier.VOLATILE);
      }
      return id;
    }
  }
  
  /**
   * Parses a interface declaration without modifier
   * @see koala.dynamicjava.tree.InterfaceDeclaration
   */
  InterfaceDeclaration unmodifiedInterfaceDeclaration(ModifierFlags mf) :
  {
    Token t;
    Token id;
    Token e;
    TypeParameter[] typeParameters = null;
    List<? extends ReferenceTypeName> impl = null;
    List<Node> list = new LinkedList<Node>();
    List<Node>  decl;
    int   m = 0;
  }
  {
    try
    {
      t="interface" id=<IDENTIFIER>
        [ typeParameters = TypeParameters() ]
        [ "extends" impl=ReferenceTypeNameList() ]
        "{"
        (
         decl=interfaceMemberDeclaration()
           {
        list.addAll(decl);
      }
      )*
        e="}"
      {
        if (mf != null) {
          m = mf.accessFlags;
        }
        if (typeParameters == null){
          return new InterfaceDeclaration(m, id.image, impl, list, _range(t, e));
        } else {
          GenericTypesEnv = GenericTypesEnv.getRest(); // pop added type params
          return new GenericInterfaceDeclaration(m, id.image, impl, list, typeParameters, _range(t, e));
        }
      }
    }
    catch(ParseException pe) {
      _throwParseException(pe, "Invalid interface declaration");
    }
  }
  
  /**
   * Parses one declaration in the body of an interface.
   * @return a list of node because one field declaration can
   *         contain multiple declarations.
   * @see koala.dynamicjava.tree.Node
   */
  List<Node> interfaceMemberDeclaration() :
  {
    Node node = null;
    List<Node> list = new LinkedList<Node>();
  }
  {
    try
    {
      ( LOOKAHEAD( classDeclarationLookahead() )
         node=classDeclaration()
         |
       LOOKAHEAD( enumDeclarationLookahead() )
         node=enumDeclaration()
         |
       LOOKAHEAD( interfaceDeclarationLookahead() )
         node=interfaceDeclaration()
         |
       LOOKAHEAD( methodDeclarationLookahead() )
         node=methodDeclaration()
         |
       list=fieldDeclaration()
         )
      {
        if (node != null) {
          list.add(node);
        }
        return list;
      }
    }
    catch(ParseException pe) {
      _throwParseException(pe, "Invalid interface member declaration");
    }
  }
  
  // Productions for Enums ////////////////////////////////////////////////////////
  
  /**
   * Parses an enum declaration
   * @see koala.dynamicjava.tree.EnumDeclaration
   */
  EnumDeclaration enumDeclaration() :
  {
    EnumDeclaration  ed;
    ModifierFlags    md;
  }
  {
    md=modifiers() ed = unmodifiedEnumDeclaration(md)
    {
      if(md != null) {
        checkModifiers(md.accessFlags, Modifier.FINAL | Modifier.ABSTRACT | Modifier.NATIVE | Modifier.SYNCHRONIZED | Modifier.TRANSIENT | Modifier.VOLATILE);
      }
      return ed;
    }
  }
  
  EnumDeclaration unmodifiedEnumDeclaration(ModifierFlags mf) :
  {
    Token            t, e;
    Token            id;
    List<? extends ReferenceTypeName> impl = null;
    EnumDeclaration.EnumBody   body;
    int   m = 0;
  }
  {
    t=<ENUM>
      id=<IDENTIFIER>
      ["implements" impl=ReferenceTypeNameList()]
      "{"
      body = enumBody()
      e="}"
    {
      if (mf != null) m = mf.accessFlags;
      return new EnumDeclaration(m, id.image, impl, body, _range(t, e));
    }
  }
  
  /**
   * Parses the body of an enum
   * @see koala.dynamicjava.tree.Node
   */
  EnumDeclaration.EnumBody enumBody() :
  {
    List<EnumDeclaration.EnumConstant> consts = new LinkedList<EnumDeclaration.EnumConstant>();
    List<Node>         decl = null;
  }
  {
    [ consts = enumConstants() ]
      [","]
      [ decl = enumBodyDeclarations() ]
    {
      return new EnumDeclaration.EnumBody(consts, ((decl==null)? new LinkedList<Node>() : decl));
    }
  }
  
  List<EnumDeclaration.EnumConstant> enumConstants() :
  {
    List<EnumDeclaration.EnumConstant> list = new LinkedList<EnumDeclaration.EnumConstant>();
    EnumDeclaration.EnumConstant individual = null;
  }
  {
    individual = enumConstant()
    { list.add(individual); }
    (LOOKAHEAD(2)
       ","
       individual = enumConstant()
       { list.add(individual); }
    )*
      
    {
      return list;
    }
  }
  
  EnumDeclaration.EnumConstant enumConstant() :
  {
    List<Node>       body = new LinkedList<Node>();
    ArgumentsSuffix args = null;
    Token                id;
    ClassBody            _classBody = null;
  }
  {
    id = <IDENTIFIER>
      [ args = arguments(null) ] // quite unnaturally, type parameters for polymorphic enum constructors (which are allowed) cannot be specified!!
      [ _classBody = classBody() ]
      
    {
      return new EnumDeclaration.EnumConstant(id.image, (args==null) ? null : args.arguments, (_classBody == null)? null : _classBody.list);
    }
  }
  
  List<Node> enumBodyDeclarations() :
  {
    List<Node> body = new LinkedList<Node>();
    List<Node> decl = null;
  }
  {
    ";"
      (
       decl = classBodyDeclaration()
         { body.addAll(decl); }
    )*
      
    {
      return body;
    }
  }
  
  
  // Productions for Arrays ////////////////////////////////////////////////////////
  
  /**
   * Parses an array initializer
   * @see koala.dynamicjava.tree.ArrayInitializer
   */
  ArrayInitializer arrayInitializer() :
  {
    Expression init;
    Token      t = null, b, e;
    List<Expression> list = new LinkedList<Expression>();
  }
  {
    b="{" [ init=variableInitializer()
             {
      list.add(init);
    }
           ( LOOKAHEAD(2)
              "," init=variableInitializer()
              {
             list.add(init);
           }
           )* ]
             [ t="," ] e="}"
           {
             return new ArrayInitializer(list, _range(b, e));
           }
  }
  
  /**
   * Parses a variable initializer (ie. an expression or an array initializer)
   * @see koala.dynamicjava.tree.Expression
   */
  Expression variableInitializer() :
  {
    Expression exp;
  }
  {
    ( exp=arrayInitializer()
       | exp=expression() )
    {
      return exp;
    }
  }
  
  // Productions for Blocks And Statements ////////////////////////////////////////////
  
  /**
   * Parses a block
   * @see koala.dynamicjava.tree.BlockStatement
   */
  BlockStatement block() :
  {
    Token p1;
    Token p2;
    List<Node> nodes;
    List<Node> list = new LinkedList<Node>();
  }
  {
    try {
      p1="{"
        ( nodes=blockStatement()
           {
        list.addAll(nodes);
      }
      )*
        p2="}"
      {
        return new BlockStatement(list, _range(p1, p2));
      }
    }
    catch(ParseException pe) {
      _throwParseException(pe,"Invalid block statement");
    }
  }
  
  /**
   * Parses one block statement.
   * @return a list of node because one variable declaration can
   *         contain multiple declarations.
   * @see koala.dynamicjava.tree.Node
   */
  List<Node> blockStatement() :
  { Node node = null; List<Node> list = null; }
  {
    try {
      (
          LOOKAHEAD(variableDeclarationLookahead()) list = localVariableDeclaration(true)
        | node = unmodifiedClassDeclaration(null)
        | node = unmodifiedEnumDeclaration(null)
        | node = unmodifiedInterfaceDeclaration(null)
        | node = statement(true)
      )
      { return (node != null) ? Collections.singletonList(node) : list; }
    }
    catch(ParseException pe) {
      _throwParseException(pe,"Invalid block statement");
    }
  }
  
  /**
   * Parses one variable declaration
   * @return a list of node because one variable declaration can
   *         contain multiple declarations.
   * @see koala.dynamicjava.tree.VariableDeclaration
   */
  List<Node> localVariableDeclaration(boolean requireSemicolon) :
  {
    Token      t    = null;
    Expression init = null;
    TypeName       typ;
    Token      id;
    int        dim  = 0;
    List<Node>       list = new LinkedList<Node>();
  }
  {
    [ t="final" ]
      typ=type() id=<IDENTIFIER> ( "[" "]" { dim++; } )*
        [ "=" init=variableInitializer() ]
      {
        list.add(createVariableDeclaration(t, typ, id, init, dim));
      }
      ( { init = null; dim = 0; }
       ","  id=<IDENTIFIER> ( "[" "]" { dim++; } )*
       [ "=" init=variableInitializer() ]
         {
         list.add(createVariableDeclaration(t, typ, id, init, dim));
       }
       )*
       (
           ";"
         | {
             Token lookahead = getToken(1);
             if (requireSemicolon || (lookahead.kind != ParserConstants.EOF && !lookahead.image.equals("}"))) {
               _throwParseException("Invalid variable declaration");
             }
           }
       )
       {
         return list;
       }
  }
  
  Node statement(boolean strictExpressions) :
  { Node node; }
  {
    (
        node = block()
      | node = emptyStatement()
      | node = ifStatement()
      | node = assertStatement()
      | node = whileStatement()
      | node = doStatement()
      | node = switchStatement()
      | node = forStatement()
      | node = breakStatement()
      | node = continueStatement()
      | node = returnStatement()
      | node = throwStatement()
      | node = synchronizedStatement()
      | node = tryStatement()
      | LOOKAHEAD(2) node = labeledStatement()
      | node = expressionStatement(strictExpressions)
    )
    { return node; }
  }
  
  /**
   * Parses a labeled statement
   * @see koala.dynamicjava.tree.ContinueTarget
   * @see koala.dynamicjava.tree.LabeledStatement
   */
  Statement labeledStatement() :
  {
    Token id;
    Node  node;
  }
  {
    id=<IDENTIFIER> ":" node=statement(true)
    {
      if (node instanceof ContinueTarget) {
        ((ContinueTarget)node).addLabel(id.image);
        return (Statement)node;
      } else {
        return new LabeledStatement(id.image, node, SourceInfo.prepend(id.beginLine, id.beginColumn, node));
      }
    }
  }
  
  /**
   * Parses an empty statement
   * @see koala.dynamicjava.tree.EmptyStatement
   */
  EmptyStatement emptyStatement() :
  {
    Token t;
  }
  {
    t=";"
    {
      return new EmptyStatement(_range(t, t));
    }
  }
  
  /**
   * Parses an if statement
   * @see koala.dynamicjava.tree.IfThenStatement
   * @see koala.dynamicjava.tree.IfThenElseStatement
   */
  Statement ifStatement() :
  {
    Token t;
    Expression exp;
    Node       stat1;
    Node       stat2 = null;
  }
  {
    try {
      t="if" ( "(" | _errorChar('('))
        exp=expression() ")"
        stat1=statement(true)
        [ LOOKAHEAD(1) "else" stat2=statement(true) ]
      {
        if (stat2 == null) {
          return new IfThenStatement(exp, stat1, SourceInfo.prepend(t.beginLine, t.beginColumn, stat1));
        } else {
          return new IfThenElseStatement(exp, stat1, stat2, SourceInfo.prepend(t.beginLine, t.beginColumn, stat2));
        }
      }
    }
    catch(ParseException pe) {
      _throwParseException(pe,"Invalid if statement");
    }
  }
  
  
  /**
   * Parses an assert statement
   * @see koala.dynamicjava.tree.AssertStatement
   */
  AssertStatement assertStatement() :
  {
    Token t, t2;
    Expression exp, falseString = null;
  }
  {
    try { 
      t="assert" exp=expression() [":" falseString=expression()] (t2=";" | t2=<EOF>)
      {   
        return new AssertStatement(exp, falseString, _range(t, t2));
      }
    }
    catch(ParseException pe) {
      _throwParseException(pe,"Invalid assert statement");
    }
  }
  
  
  /**
   * Parses a while statement
   * @see koala.dynamicjava.tree.WhileStatement
   */
  WhileStatement whileStatement() :
  {
    Token      t;
    Expression exp;
    Node       stat;
  }
  {
    
    try{
      t="while" ( "(" | _errorChar('('))
        exp=expression() ")"
        stat=statement(true)
      {
        return new WhileStatement(exp, stat, SourceInfo.prepend(t.beginLine, t.beginColumn, stat));
      }
    }
    catch(ParseException pe) {
      _throwParseException(pe,"Invalid while statement");
    }
  }
  
  /**
   * Parses a do statement
   * @see koala.dynamicjava.tree.DoStatement
   */
  DoStatement doStatement() :
  {
    Token      t1, t2;
    Expression exp;
    Node       stat;
  }
  {
    try {
      t1="do" stat=statement(true) "while"
        ( "(" | _errorChar('('))
        exp=expression() ")" t2=";"
      {
        return new DoStatement(exp, stat, _range(t1, t2));
      }
    }
    catch(ParseException pe) {
      _throwParseException(pe,"Invalid do statement");
    }
  }
  
  /**
   * Parses a switch statement
   * @see koala.dynamicjava.tree.SwitchStatement
   */
  SwitchStatement switchStatement() :
  {
    Token b, e;
    Expression sel;
    SwitchBlock sb;
    List<SwitchBlock> cases = new LinkedList<SwitchBlock>();
  }
  {
    try {
      b="switch"
        ( "(" | _errorChar('('))
        sel=expression()
        ")"
        ( "{" | _errorChar('{'))
        ( sb = switchBlock() { cases.add(sb); } )*
        e="}"
        { return new SwitchStatement(sel, cases, _range(b, e)); }
    }
    catch(ParseException pe) {
      _throwParseException(pe,"Invalid switch statement");
    }
  }
  
  SwitchBlock switchBlock() :
  {
    Token t, t2;
    Expression val = null;
    List<Node> stat;
    List<Node> allStats = new LinkedList<Node>();
    SourceInfo si;
  }
  {
    ( t="case" val=expression() | t="default" )
    ( t2 = ":" { si = _range(t, t2); } | _errorChar(':') { si = _range(t, t); } )
    (
      stat=blockStatement()
      {
        allStats.addAll(stat);
        if (stat.size() > 0)
          si = SourceInfo.span(si, stat.get(stat.size()-1));
      }
    )*
    {
      return new SwitchBlock(val, (allStats.isEmpty()) ? null: allStats, si);
    }
  }  
  
  /**
   * Parses a for statement (with standard or foreach syntax)
   * @see koala.dynamicjava.tree.ForStatement
   * Modified by Adam Wulf and David Peters
   * March 2004: Dr. Java team.
   * @see koala.dynamicjava.tree.ForSlashEachStatement
   * @see koala.dynamicjava.tree.ForEachStatement
   */
  ForSlashEachStatement forStatement() :
  {
    Token      t;
    FormalParameter forEachInit = null;
    List<Node>       init   = null;
    Expression exp    = null;
    List<Node>       update = null;
    Node       stmt;
    Token      colon  = null;
  }
  {
    try {
      t="for" ( "(" | _errorChar('('))
        (
         LOOKAHEAD(formalParameterLookahead() ":")
           forEachInit=formalParameter() colon=":" exp=expression()
           |
           ( init=forInit() | ";" )
           [ exp=expression() ] ";"
           [ update=expressionStatementList() ]
           )
        ")" stmt=statement(true)
      {
        if(colon != null){
          return new ForEachStatement(forEachInit, exp, stmt, SourceInfo.prepend(t.beginLine, t.beginColumn, stmt));
        }else{
          return new ForStatement(init, exp, update, stmt, SourceInfo.prepend(t.beginLine, t.beginColumn, stmt));
          
        }
      }
    }
    catch(ParseException pe) {
      _throwParseException(pe,"Invalid for statement");
    }
  }
  
  /**
   * Used internally to parse a 'for' statement; produces a list of
   * ExpressionStatements or a variable declaration
   */
  List<Node> forInit() :
  {
    List<Node> list;
  }
  {
    (   LOOKAHEAD( variableDeclarationLookahead() )
         list=localVariableDeclaration(true)
      | list=expressionStatementList() ";"
    )
    {
      return list;
    }
  }
  
  /**
   * Parses a comma separated list of strict ExpressionStatements
   */
  List<Node> expressionStatementList() :
  { List<Node> list = new LinkedList<Node>(); Expression exp; }
  {
    exp=statementExpression()
    {
      list.add(new ExpressionStatement(exp, true, exp.getSourceInfo()));
    }
    ( "," exp=statementExpression()
      {  list.add(new ExpressionStatement(exp, true, exp.getSourceInfo())); }
    )*
    { return list; }
  }
  
  /**
   * Parses a break statement
   * @see koala.dynamicjava.tree.BreakStatement
   */
  BreakStatement breakStatement() :
  {
    Token b, e;
    Token id = null;
  }
  {
    try {
      b="break" [ id=<IDENTIFIER> ] e=";"
      {
        return new BreakStatement((id != null) ? id.image : null, _range(b, e));
      }
    }
    catch(ParseException pe) {
      _throwParseException(pe,"Invalid break statement");
    }
  }
  
  /**
   * Parses a continue statement
   * @see koala.dynamicjava.tree.ContinueStatement
   */
  ContinueStatement continueStatement() :
  {
    Token b, e;
    Token id = null;
  }
  {
    try {
      b="continue" [ id=<IDENTIFIER> ] e=";"
      {
        return new ContinueStatement((id != null) ? id.image : null, _range(b, e));
      }
    }
    catch(ParseException pe) {
      _throwParseException(pe,"Invalid continue statement");
    }
  }
  
  /**
   * Parses a return statement
   * @see koala.dynamicjava.tree.ReturnStatement
   */
  ReturnStatement returnStatement() :
  {
    Token b, e;
    Expression exp = null;
  }
  {
    try {
      b="return" [ exp=expression() ] e=";"
      {
        return new ReturnStatement(exp, _range(b, e));
      }
    }
    catch(ParseException pe) {
      _throwParseException(pe,"Invalid return statement");
    }
  }
  
  /**
   * Parses a throw statement
   * @see koala.dynamicjava.tree.ThrowStatement
   */
  ThrowStatement throwStatement() :
  {
    Token b, e;
    Expression exp;
  }
  {
    try {
      b="throw" exp=expression() e=";"
      {
        return new ThrowStatement(exp, _range(b, e));
      }
    }
    catch(ParseException pe) {
      _throwParseException(pe,"Invalid throw statement");
    }
  }
  
  /**
   * Parses a synchronized statement
   * @see koala.dynamicjava.tree.SynchronizedStatement
   */
  SynchronizedStatement synchronizedStatement() :
  {
    Token      t;
    Expression exp;
    Node       stmt;
  }
  {
    try {
      t="synchronized" ( "(" | _errorChar('('))
        exp=expression() ")" stmt=block()
      {
        return new SynchronizedStatement(exp, stmt, SourceInfo.prepend(t.beginLine, t.beginColumn, stmt));
      }
    }
    catch(ParseException pe) {
      _throwParseException(pe,"Invalid synchronized statement");
    }
  }
  
  /**
   * Parses a try statement
   * @see koala.dynamicjava.tree.TryStatement
   */
  TryStatement tryStatement() :
  {
    Token           t, u;
    Node            tryBlock;
    Node            catchBlock;
    List<CatchStatement>      catches = new LinkedList<CatchStatement>();
    FormalParameter formal;
    Node            finallyBlock = null;
    SourceInfo si = null;
  }
  {
    try{
      t="try" tryBlock=block()
        (
          u="catch"
          ( "(" | _errorChar('('))
          formal=formalParameter()
          ")"
          catchBlock=block()
          {
            si = SourceInfo.prepend(u.beginLine, u.beginColumn, catchBlock);
            catches.add(new CatchStatement(formal, catchBlock, si));
          }
        )*
        [ "finally" finallyBlock=block() { si = finallyBlock.getSourceInfo(); } ]
        {
          if (finallyBlock == null && catches.size() == 0) {
            throw new ParseError(reader.getMessage("try.without.catch", null), _range(t, t));
          }
          return new TryStatement(tryBlock, catches, finallyBlock,
                                  SourceInfo.prepend(t.beginLine, t.beginColumn, si));
        }
    }
    catch(ParseException pe) {
      _throwParseException(pe,"Invalid try statement");
    }
  }
  
  /**
   * Parses an ExpressionStatement; if strictExpression is true,
   * a trailing semicolon is required and only StatementExpressions
   * will be allowed.
   */
  ExpressionStatement expressionStatement(boolean strictExpression) :
  { Expression exp; Token t = null; }
  {
    { lookaheadFlag = strictExpression; } // makes strictExpression visible to lookahead
    (
        LOOKAHEAD({ lookaheadFlag }) exp = statementExpression() t = ";"
      | exp = expression()
        (
            t = ";"
          | { 
              Token lookahead = getToken(1);
              if (lookahead.kind != ParserConstants.EOF && !lookahead.image.equals("}")) {
                _throwParseException("Invalid expression statement");
              }
            }
        )
    )
    {
      if (t == null) {
        return new ExpressionStatement(exp, false, exp.getSourceInfo());
      }
      else {
        return new ExpressionStatement(exp, true, SourceInfo.extend(exp, t.endLine, t.endColumn)); 
      }
    }
  }
  
  // Productions for Expressions /////////////////////////////////////////////////////////
  
  /**
   * Parses an expression
   * @see koala.dynamicjava.tree.Expression
   */
  Expression expression() :
  {
    Expression exp;
  }
  {
    exp=conditionalExpression() [ exp=expressionSuffix(exp) ]
    {
      return exp;
    }
  }
  
  /**
   * Parse only an expression that can appear as a statement
   */
  Expression statementExpression() :
  {
    Expression exp;
    Expression exp2;
    Expression exp3 = null;
    Token      t;
  }
  {
    ( exp=preIncrementExpression()
       | exp=preDecrementExpression()
       | exp=primaryExpression()
       [ t="++"
          {
      exp = new PostIncrement(exp, SourceInfo.extend(exp, t.endLine, t.endColumn));
    }
        | t="--"
          {
          exp = new PostDecrement(exp, SourceInfo.extend(exp, t.endLine, t.endColumn));
        }
        | exp=expressionSuffix(exp)
          ]
       )
        {
          if (exp instanceof StatementExpression) {
            return exp;
          } else {
            throw new ParseError(reader.getMessage("expression.statement", null), exp.getSourceInfo());
          }
        }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression expressionSuffix(Expression pre) :
  {
    Expression exp2;
    Expression exp;
  }
  {
    ( "="    exp2=expression()
       {
      exp = new SimpleAssignExpression(pre, exp2, SourceInfo.span(pre, exp2));
    }
     | "*="   exp2=expression()
       {
       exp = new MultiplyAssignExpression(pre, exp2, SourceInfo.span(pre, exp2));
     }
     | "/="   exp2=expression()
       {
       exp = new DivideAssignExpression(pre, exp2, SourceInfo.span(pre, exp2));
     }
     | "%="   exp2=expression()
       {
       exp = new RemainderAssignExpression(pre, exp2, SourceInfo.span(pre, exp2));
     }
     | "+="   exp2=expression()
       {
       exp = new AddAssignExpression(pre, exp2, SourceInfo.span(pre, exp2));
     }
     | "-="   exp2=expression()
       {
       exp = new SubtractAssignExpression(pre, exp2, SourceInfo.span(pre, exp2));
     }
     | "<<="  exp2=expression()
       {
       exp = new ShiftLeftAssignExpression(pre, exp2, SourceInfo.span(pre, exp2));
     }
     | ">>="  exp2=expression()
       {
       exp = new ShiftRightAssignExpression(pre, exp2, SourceInfo.span(pre, exp2));
     }
     | ">>>=" exp2=expression()
       {
       exp = new UnsignedShiftRightAssignExpression(pre, exp2, SourceInfo.span(pre, exp2));
     }
     | "&="   exp2=expression()
       {
       exp = new BitAndAssignExpression(pre, exp2, SourceInfo.span(pre, exp2));
     }
     | "^="   exp2=expression()
       {
       exp = new ExclusiveOrAssignExpression(pre, exp2, SourceInfo.span(pre, exp2));
     }
     | "|="   exp2=expression()
       {
       exp = new BitOrAssignExpression(pre, exp2, SourceInfo.span(pre, exp2));
     }
     )
     {
       if (!(pre instanceof LeftHandSide)) {
         throw new ParseError(reader.getMessage("left.expression.in.assignment",
                                                null),
                              pre.getSourceInfo());
       }
       return exp;
     }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression conditionalExpression() :
  {
    Expression exp;
    Expression exp2;
    Expression exp3;
  }
  {
    exp=conditionalOrExpression()
      [ "?" exp2=expression() ":" exp3=conditionalExpression()
         {
      exp = new ConditionalExpression(exp, exp2, exp3, SourceInfo.span(exp, exp3));
    }
       ]
       {
         return exp;
       }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression conditionalOrExpression() :
  {
    Expression exp;
    Expression exp2;
  }
  {
    exp=conditionalAndExpression()
      ( "||" exp2=conditionalAndExpression()
         {
      exp = new OrExpression(exp, exp2, SourceInfo.span(exp, exp2));
    }
    )*
    {
      return exp;
    }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression conditionalAndExpression() :
  {
    Expression exp;
    Expression exp2;
  }
  {
    exp=inclusiveOrExpression()
      ( "&&" exp2=inclusiveOrExpression()
         {
      exp = new AndExpression(exp, exp2, SourceInfo.span(exp, exp2));
    }
    )*
    {
      return exp;
    }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression inclusiveOrExpression() :
  {
    Expression exp;
    Expression exp2;
  }
  {
    exp=exclusiveOrExpression()
      ( "|" exp2=exclusiveOrExpression()
         {
      exp = new BitOrExpression(exp, exp2, SourceInfo.span(exp, exp2));
    }
    )*
    {
      return exp;
    }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression exclusiveOrExpression() :
  {
    Expression exp;
    Expression exp2;
  }
  {
    exp=andExpression()
      ( "^" exp2=andExpression()
         {
      exp = new ExclusiveOrExpression(exp, exp2, SourceInfo.span(exp, exp2));
    }
    )*
    {
      return exp;
    }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression andExpression() :
  {
    Expression exp;
    Expression exp2;
  }
  {
    exp=equalityExpression()
      ( "&" exp2=equalityExpression()
         {
      exp = new BitAndExpression(exp, exp2, SourceInfo.span(exp, exp2));
    }
    )*
    {
      return exp;
    }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression equalityExpression() :
  {
    Expression exp;
    Expression exp2;
  }
  {
    exp=instanceOfExpression()
      ( "==" exp2=instanceOfExpression()
         {
      exp = new EqualExpression(exp, exp2, SourceInfo.span(exp, exp2));
    }
       | "!=" exp2=instanceOfExpression()
         {
         exp = new NotEqualExpression(exp, exp2, SourceInfo.span(exp, exp2));
       }
       )*
       {
         return exp;
       }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression instanceOfExpression() :
  {
    Expression exp;
    TypeName       typ = null;
  }
  {
    exp=relationalExpression() [ "instanceof" typ=type() ]
    {
      if (typ != null) {
        return new InstanceOfExpression(exp, typ, SourceInfo.span(exp, typ));
      } else {
        return exp;
      }
    }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression relationalExpression() :
  {
    Expression exp;
    Expression exp2;
  }
  {
    exp=shiftExpression()
      ( LOOKAHEAD(1) ( // consume as large an expression as possible
        "<"  exp2=shiftExpression()
         {
            exp = new LessExpression(exp, exp2, SourceInfo.span(exp, exp2));
         }
       | ">"  exp2=shiftExpression()
         {
         exp = new GreaterExpression(exp, exp2, SourceInfo.span(exp, exp2));
         }
       | "<=" exp2=shiftExpression()
         {
         exp = new LessOrEqualExpression(exp, exp2, SourceInfo.span(exp, exp2));
         }
       | ">=" exp2=shiftExpression()
         {
         exp = new GreaterOrEqualExpression(exp, exp2, SourceInfo.span(exp, exp2));
         }
       ))*
       {
         return exp;
       }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression shiftExpression() :
  {
    Expression exp;
    Expression exp2;
  }
  {
    exp=additiveExpression()
      ( "<<"  exp2=additiveExpression()
         {
      exp = new ShiftLeftExpression(exp, exp2, SourceInfo.span(exp, exp2));
    }
       | <RSSHIFT1> <RSSHIFT2>  exp2=additiveExpression()
         {
         exp = new ShiftRightExpression(exp, exp2, SourceInfo.span(exp, exp2));
       }
       | <RUSHIFT1> <RUSHIFT2> <RUSHIFT3> exp2=additiveExpression()
         {
         exp = new UnsignedShiftRightExpression(exp, exp2, SourceInfo.span(exp, exp2));
       }
       )*
       {
         return exp;
       }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression additiveExpression() :
  {
    Expression exp;
    Expression exp2;
  }
  {
    exp=multiplicativeExpression()
      ( LOOKAHEAD(1) (// consume as large an expression as possible
        "+" exp2=multiplicativeExpression()
         {
           exp = new AddExpression(exp, exp2, SourceInfo.span(exp, exp2));
         }
       | "-" exp2=multiplicativeExpression()
         {
           exp = new SubtractExpression(exp, exp2, SourceInfo.span(exp, exp2));
         }
       ))*
       {
         return exp;
       }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression multiplicativeExpression() :
  {
    Expression exp;
    Expression exp2;
  }
  {
    exp=unaryExpression()
      ( "*" exp2=unaryExpression()
         {
      exp = new MultiplyExpression(exp, exp2, SourceInfo.span(exp, exp2));
    }
       | "/" exp2=unaryExpression()
         {
         exp = new DivideExpression(exp, exp2, SourceInfo.span(exp, exp2));
       }
       | "%" exp2=unaryExpression()
         {
         exp = new RemainderExpression(exp, exp2, SourceInfo.span(exp, exp2));
       }
       )*
       {
         return exp;
       }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression unaryExpression() :
  {
    Expression exp = null;
    Token      t,tk;
  }
  {
    ( t="+" exp=unaryExpression()
       {
      return new PlusExpression(exp, SourceInfo.prepend(t.beginLine, t.beginColumn, exp));
    }
     |
     t="-" (LOOKAHEAD(1)tk=<INTEGER_LITERAL>{ return new IntegerLiteral("-"+tk.image, _range(t, tk)); }
            |LOOKAHEAD(1)tk=<LONG_LITERAL>{
              if(tk.image.endsWith("L")) tk.image=tk.image.substring(0,tk.image.length()-1);
              return new LongLiteral("-"+tk.image, _range(t, tk)); 
             }
           | exp=unaryExpression(){
               return new MinusExpression(exp, SourceInfo.prepend(t.beginLine, t.beginColumn, exp));
             }
           )
     |
     exp=preIncrementExpression()
       |
     exp=preDecrementExpression()
       |
     exp=unaryExpressionNotPlusMinus() )
     {
       return exp;
     }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression unaryExpressionNotPlusMinus() :
  {
    Expression exp;
    Token      t;
  }
  {
    ( t="~" exp=unaryExpression()
       {
      return new ComplementExpression(exp, SourceInfo.prepend(t.beginLine, t.beginColumn, exp));
    }
     |
     t="!" exp=unaryExpression()
       {
       return new NotExpression(exp, SourceInfo.prepend(t.beginLine, t.beginColumn, exp));
     }
     |
     LOOKAHEAD( castLookahead() )
       exp=castExpression()
       |
     exp=postfixExpression() )
     {
       return exp;
     }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression castExpression() :
  {
    TypeName       typ;
    Token      t;
    Expression exp;
  }
  {
    ( LOOKAHEAD("(" primitiveTypeLookahead())
       t="(" typ=type() ")" exp=unaryExpression()
       |
     t="(" typ=type() ")" exp=unaryExpressionNotPlusMinus() )
    {
      return new CastExpression(typ, exp, SourceInfo.prepend(t.beginLine, t.beginColumn, exp));
    }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression preIncrementExpression() :
  {
    Expression pe;
    Token      t;
  }
  {
    t="++" pe=primaryExpression()
    {
      return new PreIncrement(pe, SourceInfo.prepend(t.beginLine, t.beginColumn, pe));
    }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression preDecrementExpression() :
  {
    Expression pe;
    Token      t;
  }
  {
    t="--" pe=primaryExpression()
    {
      return new PreDecrement(pe, SourceInfo.prepend(t.beginLine, t.beginColumn, pe));
    }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression postfixExpression() :
  {
    Expression pe;
    Token      t;
  }
  {
    pe=primaryExpression()
      [ LOOKAHEAD(1) (// consume as large an expression as possible
        t="++"
         {
           return new PostIncrement(pe, SourceInfo.extend(pe, t.endLine, t.endColumn));
         }
       | t="--"
         {
         return new PostDecrement(pe, SourceInfo.extend(pe, t.endLine, t.endColumn));
       }
       )]
       { return pe; }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression primaryExpression() :
  {
    Expression       pp;
    ExpressionSuffix es;
    List<ExpressionSuffix> list = new LinkedList<ExpressionSuffix>();
    List<TypeName> typeArgs = new LinkedList<TypeName>();
  }
  {
    [LOOKAHEAD(TypeArguments()) typeArgs = TypeArguments()]
      pp=primaryPrefix()
      ( LOOKAHEAD(2) es=primarySuffix(typeArgs)
         {
      // Build the list of suffixes in reverse order
      list.add(0, es);
    }
    )*
    {
      return createPrimaryExpression(pp, list);
    }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression primaryPrefix() :
  {
    Expression exp;
  }
  {
    ( exp=literal()
       | exp=thisExpression()
       | exp=superExpression()
       | exp=allocationExpression()
       | "(" exp=expression() ")"
       | LOOKAHEAD( resultTypeLookahead() "." "class" ) exp=classExpression()
       | exp=qualifiedName()
       )
    {
      return exp;
    }
  }
  
  /**
   * Used internally to parse an expression
   */
  ExpressionSuffix primarySuffix(List<TypeName> typeArgs) :
  {
    ExpressionSuffix es;
  }
  {
    ( LOOKAHEAD(2) es=dotThis()
       | LOOKAHEAD(2) es=dotAllocationExpression()
       | es=arrayReference()
       | es=dotIdentifier()
       | es=arguments(typeArgs)
       )
    {
      return es;
    }
  }
  
  /**
   * Used internally to parse an expression
   */
  ExpressionSuffix dotThis() :
  {
    Token t;
  }
  {
    "." t="this"
    {
      return new DotThisSuffix(_range(t, t));
    }
  }
  
  /**
   * Used internally to parse an expression
   */
  ExpressionSuffix dotAllocationExpression() :
  {
    SimpleAllocation a;
  }
  {
    "." a=simpleAllocationExpression()
    {
      return new DotAllocationSuffix(a);
    }
  }
  
  /**
   * Used internally to parse an expression
   */
  SimpleAllocation simpleAllocationExpression() :
  {
    Token           t;
    ReferenceTypeName   rt;
    ArgumentsSuffix as;
    ClassBody       cb = null;
    List<TypeName> typeArgs = new LinkedList<TypeName>();
  }
  {
    
    t="new"
      [LOOKAHEAD(TypeArguments()) typeArgs = TypeArguments()]
      rt=ReferenceTypeName() as=arguments(typeArgs)
      [ LOOKAHEAD(1) // consume as large an expression as possible
        cb=classBody()
      ]
    {
      if (cb == null) {
        SourceInfo si = SourceInfo.prepend(t.beginLine, t.beginColumn, as);
        if(typeArgs.size() > 0) return new PolymorphicSimpleAllocation(rt, as.arguments, typeArgs, si);
        else return new SimpleAllocation(rt, as.arguments, si);
      } else {
        SourceInfo si = SourceInfo.prepend(t.beginLine, t.beginColumn, cb);
        if(typeArgs.size() > 0) return new PolymorphicAnonymousAllocation(rt, as.arguments, cb.list, typeArgs, si);
        else return new AnonymousAllocation(rt, as.arguments, cb.list, si);
      }
    }
  }
  
  /**
   * Used internally to parse an expression
   */
  ExpressionSuffix dotIdentifier() :
  {
    Token id;
  }
  {
    "." id=<IDENTIFIER>
    {
      return new DotIdentifierSuffix(id);
    }
  }
  
  /**
   * Used internally to parse an expression
   */
  ExpressionSuffix arrayReference() :
  {
    Expression exp;
    Token      left, right;
  }
  {
    left="[" exp=expression() right="]"
    {
      return new ArrayReferenceSuffix(exp, _range(left, right));
    }
  }
  
  /**
   * Used internally to parse an expression
   */
  ArgumentsSuffix arguments(List<TypeName> typeArgs) :
  {
    List<Expression> list = null;
    Token left, right;
  }
  {
    left="(" [ list=argumentList() ] right=")"
    {
      return new ArgumentsSuffix(list, typeArgs, _range(left, right));
    }
  }
  
  /**
   * Used internally to parse an expression
   */
  List<Expression> argumentList() :
  {
    List<Expression> list = new LinkedList<Expression>();
    Expression exp;
  }
  {
    exp=expression()
    {
      list.add(exp);
    }
    ( "," exp=expression()
       {
      list.add(exp);
    }
    )*
    {
      return list;
    }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression literal() :
  {
    Token t;
  }
  {
    try {
      t=<INTEGER_LITERAL>
      {
        // if(t.image.equals("2147483648")){t.image = "-2147483648";} // Introduced an error with int x = 2147483648
        
        
        return new IntegerLiteral(t.image, _range(t, t));
      }
      |
        t=<LONG_LITERAL>
      {
        if(t.image.endsWith("L")) t.image=t.image.substring(0,t.image.length()-1);
           return new LongLiteral(t.image, _range(t, t));
      }
      |
        t=<FLOAT_LITERAL>
      {
        return new FloatLiteral(t.image, _range(t, t));
      }
      |
        t=<DOUBLE_LITERAL>
      {
        return new DoubleLiteral(t.image, _range(t, t));
      }
      |
        t=<CHARACTER_LITERAL>
      {
        return new CharacterLiteral(t.image, _range(t, t));
      }
      |
        t=<STRING_LITERAL>
      {
        return new StringLiteral(t.image, _range(t, t));
      }
      |
        t="true"
      {
        return new BooleanLiteral(true, _range(t, t));
      }
      |
        t="false"
      {
        return new BooleanLiteral(false, _range(t, t));
      }
      |
        t="null"
      {
        return new NullLiteral(_range(t, t));
      }
    }
    catch (ParseException pe) {
      _throwParseException(pe, "This is an illegal literal!");
    }
  }
  /**
   * Used internally to parse an expression
   */
  Expression thisExpression() :
  {
    Token t;
  }
  {
    t="this"
    {
      return new ThisExpression(new LinkedList<IdentifierToken>(), _range(t, t));
    }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression superExpression() :
  {
    Token t;
    Token id;
  }
  {
    t="super" "." id=<IDENTIFIER>
    {
      return new CompileTimeSuperExpression(id.image, _range(t, id));
    }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression qualifiedName() :
  {
    List<IdentifierToken> list;
  }
  {
    list=name()
    {
      return new CompileTimeQualifiedName(list);
    }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression classExpression() :
  {
    TypeName  typ;
    Token t;
  }
  {
    typ=resultType() "." t="class"
    {
      return new TypeExpression(typ, SourceInfo.extend(typ, t.endLine, t.endColumn));
    }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression allocationExpression() :
  {
    Token t;
    ArrayAllocation.TypeDescriptor td;
    TypeName            primT;
    ReferenceTypeName   refT;
    ArgumentsSuffix as;
    ClassBody       cb = null;
    List<TypeName> typeArgs = new LinkedList<TypeName>();
  }
  {
    ( LOOKAHEAD(2)
       t="new" primT=primitiveType() td=arrayDimsAndInits()
       {
      return new ArrayAllocation(primT, td, SourceInfo.prepend(t.beginLine, t.beginColumn, td));
    }
     |
     t="new"
       [LOOKAHEAD(TypeArguments()) typeArgs = TypeArguments()]
       refT = ReferenceTypeName()
       ( td=arrayDimsAndInits()
          {
       return new ArrayAllocation(refT, td, SourceInfo.prepend(t.beginLine, t.beginColumn, td));
     }
        | as=arguments(typeArgs)
        [ LOOKAHEAD(1) // consume as large an expression as possible
          cb=classBody()
        ]
          {
          if (cb == null) {
            return new SimpleAllocation(refT, as.arguments, SourceInfo.prepend(t.beginLine, t.beginColumn, as));
          } else {
            return new AnonymousAllocation(refT, as.arguments, cb.list,
                                           SourceInfo.prepend(t.beginLine, t.beginColumn, cb));
          }
        }
        )
       )
  }
  
  /**
   * Used internally to parse an expression
   */
  ArrayAllocation.TypeDescriptor arrayDimsAndInits() :
  {
    List<Expression>  dims = new LinkedList<Expression>();
    int   dim  = 0;
    Token left, right;
    Expression exp;
    ArrayInitializer ai;
  }
  {
    ( LOOKAHEAD(2)
       ( LOOKAHEAD(2)
          left="[" exp=expression() right="]"
          { dims.add(exp); }
        )+
        ( LOOKAHEAD(2) left="[" right="]" { dim++; } )*
       {
         return new ArrayAllocation.TypeDescriptor(dims, dim+dims.size(), null, _range(left, right));
       }
    |
       ( left = "[" "]" { dim++; } )+
       ai=arrayInitializer()
         {
           return new ArrayAllocation.TypeDescriptor(dims, dim, ai,
                                                     SourceInfo.prepend(left.beginLine, left.beginColumn, ai));
         }
    )
  }
  
  // Productions for Types ///////////////////////////////////////////////////////////
  
  /**
   * Used internally to parse types
   */
  TypeName type() :
  {
    int   dim = 0;
    TypeName  pt  = null;
    Token t   = null;
    TypeName rt = null;
  }
  {
    ( pt=primitiveType()
       | rt=ReferenceTypeName()
       )
      ( "[" t="]"  /**/ // Why does it complain about conflict here, so we put LOOKAHEAD(2)
         {
      dim++;
    }
    )*
    {
      if (pt != null) {
        rt = pt;
      }
      if (dim == 0) {
        return rt;
      } else {
        return new ArrayTypeName(rt, dim, false, SourceInfo.extend(rt, t.endLine, t.endColumn));
      }
    }
  }
  
  /**
   * Used internally to parse types
   */
  TypeName resultType() :
  {
    TypeName  typ;
    Token t;
  }
  {
    t="void"
    {
      return new VoidTypeName(_range(t, t));
    }
    |
      typ=type()
    {
      return typ;
    }
  }
  
  /**
   * Used internally to parse types
   */
  TypeName primitiveType() :
  {
    Token t;
  }
  {
    t="boolean"
    {
      return new BooleanTypeName(_range(t, t));
    }
    |
      t="char"
    {
      return new CharTypeName(_range(t, t));
    }
    |
      t="byte"
    {
      return new ByteTypeName(_range(t, t));
    }
    |
      t="short"
    {
      return new ShortTypeName(_range(t, t));
    }
    |
      t="int"
    {
      return new IntTypeName(_range(t, t));
    }
    |
      t="long"
    {
      return new LongTypeName(_range(t, t));
    }
    |
      t="float"
    {
      return new FloatTypeName(_range(t, t));
    }
    |
      t="double"
    {
      return new DoubleTypeName(_range(t, t));
    }
  }
  
  
  // Lookahead productions ////////////////////////////////////////////////////////
  
  /**
   * Looks ahead for one top level statement
   */
  void topLevelStatementLookahead() :
  {
  }
  {
    "package" | "import" | "{" | ";" | "if" | "assert" | "while" | "do" | "switch" | "for" | "break" | "continue" | "return" | "throw" | "try"
      |  LOOKAHEAD(2) ("synchronized" "(")
      | LOOKAHEAD(2) (<IDENTIFIER> ":")
      | LOOKAHEAD(methodDeclarationLookahead()) methodDeclarationLookahead()
      | LOOKAHEAD(["final"] typeLookahead() <IDENTIFIER>) (["final"] typeLookahead() <IDENTIFIER>)
      | LOOKAHEAD(typeDeclarationLookahead())  typeDeclarationLookahead()
      | LOOKAHEAD(expression() ";") (expression() ";")
  }
  
  /**
   * Looks ahead for a type declatarion
   */
  void typeDeclarationLookahead() :
  {
  }
  {
    LOOKAHEAD(classDeclarationLookahead()) classDeclarationLookahead()
      | LOOKAHEAD(enumDeclarationLookahead()) enumDeclarationLookahead()
      | LOOKAHEAD(interfaceDeclarationLookahead()) interfaceDeclarationLookahead()
  }
  
  /**
   * Used internally for lookahead
   */
  void castLookahead() :
  {}
  {
    LOOKAHEAD(2)
      "(" primitiveTypeLookahead()
      |
      LOOKAHEAD("(" nameLookahead() "[")
      "(" nameLookahead() "[" "]"
      |
      "(" nameLookahead() ")"
      ( "~" | "!" | "(" | <IDENTIFIER> | "this" | "super" | "new" | literalLookahead() )
  }
  
  /**
   * Used internally for lookahead
   */
  void typeLookahead() :
  {}
  {
    ( primitiveTypeLookahead() | nameLookahead() ) ( "[" "]" )*
  }
  
  /**
   * Used internally for lookahead
   */
  void resultTypeLookahead() :
  {}
  {
    "void" | typeLookahead()
  }
  
  /**
   * Used internally for lookahead
   */
  void nameLookahead() :
  {}
  {
    <IDENTIFIER> [ LOOKAHEAD(TypeArguments()) TypeArguments() ] ( LOOKAHEAD(2) "." <IDENTIFIER> [ LOOKAHEAD(TypeArguments()) TypeArguments() ])*
  }
  
  /**
   * Used internally for lookahead
   */
  void primitiveTypeLookahead() :
  {}
  {
    "boolean" | "char" | "byte" | "short" | "int" | "long" | "float" | "double"
  }
  
  /**
   * Used internally for lookahead
   */
  void literalLookahead() :
  {}
  {
    <INTEGER_LITERAL>
      |
      <LONG_LITERAL>
      |
      <FLOAT_LITERAL>
      |
      <DOUBLE_LITERAL>
      |
      <CHARACTER_LITERAL>
      |
      <STRING_LITERAL>
      |
      "true"
      |
      "false"
      |
      "null"
  }
  
  /**
   * Used internally for lookahead
   */
  void explicitConstructorCallLookahead() :
  {}
  {
    LOOKAHEAD( "this" argumentsLookahead() ";" )
      "this" argumentsLookahead() ";"
      |
      [ LOOKAHEAD(2) primaryExpressionLookahead() "." ]
      "super" argumentsLookahead() ";"
  }
  
  /**
   * Used internally for lookahead
   */
  void argumentsLookahead() :
  {}
  {
    "(" [ expressionLookahead() ( "," expressionLookahead() )* ] ")"
  }
  
  /**
   * Used internally for lookahead
   */
  void expressionLookahead() :
  {}
  {
    conditionalExpressionLookahead()
      [  assignmentOperatorLookahead() expressionLookahead() ]
  }
  
  /**
   * Used internally for lookahead
   */
  void assignmentOperatorLookahead() :
  {}
  {
    "=" | "*=" | "/=" | "%=" | "+=" | "-=" | "<<=" | ">>=" | ">>>=" | "&=" | "^=" | "|="
  }
  
  /**
   * Used internally for lookahead
   */
  void conditionalExpressionLookahead() :
  {}
  {
    conditionalOrExpressionLookahead()
      [ "?" expressionLookahead() ":" conditionalExpressionLookahead() ]
  }
  
  /**
   * Used internally for lookahead
   */
  void conditionalOrExpressionLookahead() :
  {}
  {
    conditionalAndExpressionLookahead() ( "||" conditionalAndExpressionLookahead() )*
  }
  
  /**
   * Used internally for lookahead
   */
  void conditionalAndExpressionLookahead() :
  {}
  {
    inclusiveOrExpressionLookahead() ( "&&" inclusiveOrExpressionLookahead() )*
  }
  
  /**
   * Used internally for lookahead
   */
  void inclusiveOrExpressionLookahead() :
  {}
  {
    exclusiveOrExpressionLookahead() ( "|" exclusiveOrExpressionLookahead() )*
  }
  
  /**
   * Used internally for lookahead
   */
  void exclusiveOrExpressionLookahead() :
  {}
  {
    andExpressionLookahead() ( "^" andExpressionLookahead() )*
  }
  
  /**
   * Used internally for lookahead
   */
  void andExpressionLookahead() :
  {}
  {
    equalityExpressionLookahead() ( "&" equalityExpressionLookahead() )*
  }
  
  /**
   * Used internally for lookahead
   */
  void equalityExpressionLookahead() :
  {}
  {
    instanceOfExpressionLookahead() ( ( "==" | "!=" ) instanceOfExpressionLookahead() )*
  }
  
  /**
   * Used internally for lookahead
   */
  void instanceOfExpressionLookahead() :
  {}
  {
    relationalExpressionLookahead() [ "instanceof" typeLookahead() ]
  }
  
  /**
   * Used internally for lookahead
   */
  void relationalExpressionLookahead() :
  {}
  {
    shiftExpressionLookahead()
      ( ( "<" | ">" | "<=" | ">=" ) shiftExpressionLookahead() )*
  }
  
  /**
   * Used internally for lookahead
   */
  void shiftExpressionLookahead() :
  {}
  {
    additiveExpressionLookahead()
      ( ( "<<" | ">>" | ">>>" ) additiveExpressionLookahead() )*
  }
  
  /**
   * Used internally for lookahead
   */
  void additiveExpressionLookahead() :
  {}
  {
    multiplicativeExpressionLookahead()
      ( ( "+" | "-" ) multiplicativeExpressionLookahead() )*
  }
  
  /**
   * Used internally for lookahead
   */
  void multiplicativeExpressionLookahead() :
  {}
  {
    unaryExpressionLookahead() ( ( "*" | "/" | "%" ) unaryExpressionLookahead() )*
  }
  
  /**
   * Used internally for lookahead
   */
  void unaryExpressionLookahead() :
  {}
  {
    ( "+" | "-" ) unaryExpressionLookahead()
      |
      preIncrementExpressionLookahead()
      |
      preDecrementExpressionLookahead()
      |
      unaryExpressionNotPlusMinusLookahead()
  }
  
  /**
   * Used internally for lookahead
   */
  void preIncrementExpressionLookahead() :
  {}
  {
    "++" primaryExpressionLookahead()
  }
  
  /**
   * Used internally for lookahead
   */
  void preDecrementExpressionLookahead() :
  {}
  {
    "--" primaryExpressionLookahead()
  }
  
  /**
   * Used internally for lookahead
   */
  void unaryExpressionNotPlusMinusLookahead() :
  {}
  {
    ( "~" | "!" ) unaryExpressionLookahead()
      |
      LOOKAHEAD( castLookahead() ) castExpressionLookahead()
      |
      postfixExpressionLookahead()
  }
  
  /**
   * Used internally for lookahead
   */
  void postfixExpressionLookahead() :
  {}
  {
    primaryExpressionLookahead() [ "++" | "--" ]
  }
  
  /**
   * Used internally for lookahead
   */
  void castExpressionLookahead() :
  {}
  {
    LOOKAHEAD( "(" primitiveTypeLookahead() )
      "(" typeLookahead() ")" unaryExpressionLookahead()
      |
      "(" typeLookahead() ")" unaryExpressionNotPlusMinusLookahead()
  }
  
  /**
   * Used internally for lookahead
   */
  void primaryExpressionLookahead() :
  {}
  {
    primaryPrefixLookahead() ( LOOKAHEAD(2) primarySuffixLookahead() )*
  }
  
  /**
   * Used internally for lookahead
   */
  void primaryPrefixLookahead() :
  {}
  {
    literalLookahead()
      |
      "this"
      |
      "super" "." <IDENTIFIER>
      |
      "(" expressionLookahead() ")"
      |
      allocationExpressionLookahead()
      |
      LOOKAHEAD( resultTypeLookahead() "." "class" )
      resultTypeLookahead() "." "class"
      |
      nameLookahead()
  }
  
  /**
   * Used internally for lookahead
   */
  void primarySuffixLookahead() :
  {}
  {
    LOOKAHEAD(2) "." "this"
      |
      LOOKAHEAD(2) "." allocationExpressionLookahead()
      |
      "[" expressionLookahead() "]"
      |
      "." <IDENTIFIER>
      |
      argumentsLookahead()
  }
  
  /**
   * Used internally for lookahead
   */
  void allocationExpressionLookahead() :
  {}
  {
    LOOKAHEAD(2) "new" primitiveTypeLookahead() arrayDimsAndInitsLookahead()
      |
      "new" nameLookahead()
      ( arrayDimsAndInitsLookahead()
         | argumentsLookahead() [ "{" ] )
  }
  
  /**
   * Used internally for lookahead
   */
  void initializerLookahead() :
  {}
  {
    [ "static" ] "{"
  }
  
  /**
   * Used internally for lookahead
   */
  void modifiersLookahead() :
  {}
  {
    ( "public"   | "protected" | "private" |  "static"   |
     "abstract" | "final" | "native" |  "synchronized" | "transient" | "volatile" )*
  }
  
  /**
   * Used internally for lookahead
   */
  void constructorDeclarationLookahead() :
  {}
  {
    modifiersLookahead() [ TypeParametersLookahead() ] <IDENTIFIER> "("
  }
  
  /**
   * Used internally for lookahead
   */
  void methodDeclarationLookahead() :
  {}
  {
    modifiersLookahead()
      [ TypeParametersLookahead() ]
      resultTypeLookahead()  <IDENTIFIER>  "("
  }
  
  /**
   * Used internally for lookahead
   * Overlaps methodDeclarationLookahead, so must always be used afterwards
   * (where both can appear in the same context)
   */
  void variableDeclarationLookahead() :
  {}
  {
    [ "final" ] typeLookahead() <IDENTIFIER>
  }
  
  /**
   * Used internally for lookahead
   */
  void nameListLookahead() :
  {}
  {
    nameLookahead() ( "," nameLookahead() )*
  }
  
  /**
   * Used internally for lookahead
   */
  void methodDeclaratorLookahead() :
  {}
  {
    <IDENTIFIER> formalParametersLookahead() ( "[" "]" )*
  }
  
  /**
   * Used internally for lookahead
   */
  void formalParametersLookahead() :
  {}
  {
    "(" [ formalParameterLookahead() ( "," formalParameterLookahead() )* ] ")"
  }
  
  /**
   * Used internally for lookahead
   */
  void formalParameterLookahead() :
  {}
  {
    [ "final" ] typeLookahead() variableDeclaratorIdLookahead()
  }
  
  void varArgsFormalParameterLookahead() :
  {}
  {
    [ "final" ] typeLookahead() <VAR_ARGS> variableDeclaratorIdLookahead()
  }
  
  /**
   * Used internally for lookahead
   */
  void fieldDeclarationLookahead() :
  {}
  {
    modifiersLookahead()
      typeLookahead() variableDeclaratorLookahead()
      ( "," variableDeclaratorLookahead() )* ";"
  }
  
  /**
   * Used internally for lookahead
   */
  void variableDeclaratorLookahead() :
  {}
  {
    variableDeclaratorIdLookahead() [ "=" variableInitializerLookahead() ]
  }
  
  /**
   * Used internally for lookahead
   */
  void variableDeclaratorIdLookahead() :
  {}
  {
    <IDENTIFIER> ( "[" "]" )*
  }
  
  /**
   * Used internally for lookahead
   */
  void localVariableDeclarationLookahead() :
  {}
  {
    [ "final" ] typeLookahead() variableDeclaratorLookahead()
      ( "," variableDeclaratorLookahead() )*
  }
  
  /**
   * Used internally for lookahead
   */
  void arrayDimsAndInitsLookahead() :
  {}
  {
    LOOKAHEAD(2)
      ( LOOKAHEAD(2) "[" expressionLookahead() "]" )+ ( LOOKAHEAD(2) "[" "]" )*
      |
      ( "[" "]" )+ arrayInitializerLookahead()
  }
  
  /**
   * Used internally for lookahead
   */
  void arrayInitializerLookahead() :
  {}
  {
    "{" [ variableInitializerLookahead()
           ( LOOKAHEAD(2) "," variableInitializerLookahead() )* ] [ "," ] "}"
  }
  
  /**
   * Used internally for lookahead
   */
  void variableInitializerLookahead() :
  {}
  {
    arrayInitializerLookahead() | expressionLookahead()
  }
  
  /**
   * Used internally for lookahead
   */
  void classDeclarationLookahead() :
  {}
  {
    modifiersLookahead() "class"
  }
  
  /**
   * Used internally for lookahead
   */
  void enumDeclarationLookahead() :
  {}
  {
    modifiersLookahead() "enum"
  }
  
  /**
   * Used internally for lookahead
   */
  void interfaceDeclarationLookahead() :
  {}
  {
    modifiersLookahead() "interface"
  }
  
  /* Additions to DynamicJava grammar to parse Generics */
  
  TypeParameter[] TypeParameters() :
  {
    List<TypeParameter> list = new LinkedList<TypeParameter>();
    TypeParameter temp;
  }
  {
    <LESS>
      temp = TypeParameter() { list.add(temp); TypeParamsMap.put(temp.getName(), temp); }
    (
     <COMMA>
     temp = TypeParameter() { list.add(temp); TypeParamsMap.put(temp.getName(), temp); }
    )*
      RightAngledBracket()
    {
      GenericTypesEnv = GenericTypesEnv.extend(TypeParamsMap); // push the map of typename/typeparam to the generic types env
      TypeParamsMap = new HashMap<String, TypeParameter>(); // flush old map
      return list.toArray(new TypeParameter[0]);
    }
  }
  
  // Does not add the peeked type params to the type environment
  TypeParameter[] TypeParametersLookahead() :
  {
    List<TypeParameter> list = new LinkedList<TypeParameter>();
    TypeParameter temp;
  }
  {
    <LESS>
      temp = TypeParameter() { list.add(temp); }
    (
     <COMMA>
     temp = TypeParameter() { list.add(temp); }
    )*
      RightAngledBracket()
    {
      return list.toArray(new TypeParameter[0]);
    }
  }
  
  TypeParameter TypeParameter() :
  {
    List<IdentifierToken> name;
    TypeName bound = new ReferenceTypeName("Object");
    List<ReferenceTypeName> interfaceBoundsList = new LinkedList<ReferenceTypeName>();
    ReferenceTypeName interf;
    SourceInfo.Wrapper last;
  }
  {
    name = name() { last = name.get(name.size()-1); }
      [
       "extends"
         bound = type() { last = bound; }
         ("&" interf = ReferenceTypeName()
            {
              interfaceBoundsList.add(interf);
              last = interf;
            }
         )*
       ]
    {
      IdentifierToken first = name.get(0);
      if(bound instanceof ReferenceTypeName){
        return new TypeParameter(name, (ReferenceTypeName)bound, interfaceBoundsList, SourceInfo.span(first, last));
      } else {
        throw new ParseError("Primitives are not allowed as bound"+
                              "types, and array types are temporarily disabled due to a "+
                              "DynamicJava AST hierarchy bug!", first.getSourceInfo());
      }
    }
  }
  
  List<TypeName> TypeArguments() :
  {
    List<TypeName> typeArgs = new LinkedList<TypeName>();
    TypeName arg;
  }
  {
    <LESS>
    arg = TypeArgument() { typeArgs.add(arg); }
    ( <COMMA> arg = TypeArgument() { typeArgs.add(arg); } )*
    RightAngledBracket() { return typeArgs; }
  }
  
  TypeName TypeArgument() :
  { Token hook; TypeName upper = null; TypeName lower = null; }
  {
    (
      hook="?" ( "extends" upper = type() )? ( "super" lower = type() )?
      {
        SourceInfo si = _range(hook, hook);
        if (upper != null) { si = SourceInfo.span(si, upper); }
        if (lower != null) { si = SourceInfo.span(si, lower); }
        return new HookTypeName(Option.wrap(upper), Option.wrap(lower), si);
      }
    | upper = type() { return upper; }
    )
  }
  
  Token RightAngledBracket() :
  {
    Token t;
  }
  {
    ( t=<GREATER_THAN> | t=<RSSHIFT1> | t=<RSSHIFT2> | t=<RUSHIFT1> | t=<RUSHIFT2> | t=<RUSHIFT3> )
    { return t; }
  }