/* -*- Java -*- */
// Parser options
//
options {
  JAVA_UNICODE_ESCAPE    = true;
  STATIC                 = false;
}

PARSER_BEGIN(Parser)
  package koala.dynamicjava.parser.impl;

import java.lang.reflect.Modifier;
import java.util.*;
import java.io.File;

import koala.dynamicjava.SourceInfo;
import koala.dynamicjava.parser.wrapper.*;
import koala.dynamicjava.tree.*;
import koala.dynamicjava.tree.visitor.*;
import koala.dynamicjava.util.*;
import koala.dynamicjava.tree.tiger.generic.*;

/**
 * This class represents a (interpreted) Java 1.1 language parser
 * adapted for 1.5 language extensions.
 */

public class Parser {
  /**
   * The name of the file currently interpreted
   */
  private String filename;
  
  /**
   * An environment that has the generic type parameters defined
   * at any point.
   *
   * Used as a stack, pushed if TypeParameters are parsed (in
   * a class/interface/method declaration), and popped after
   * parsing whole scope (class, interface, or method).
   */
  private Environment<String, TypeParameter> GenericTypesEnv =
    new EmptyEnv<String, TypeParameter>();
  
  private Map<String, TypeParameter> TypeParamsMap = new HashMap<String, TypeParameter>();
  // contains the latest defined type parameters list whose
  // full declaration has not finished yet. That is to take
  // care of the fact that the scope of a type parameter
  // covers the rest of the definition of the type parameters
  // list beyond a parameter's own definition (for example,
  // class Enum<E extends Enum<E>>, in Java 1.5 API). When
  // checking for a type parameter, this Map has to be checked
  // first before the GenericTypesEnv environment.
  
  boolean lastFormalParameterIsVarArgs = false;
  
  /**
   * The message reader
   */
  private LocalizedMessageReader reader =
    new LocalizedMessageReader("koala.dynamicjava.parser.resources.messages");
  
  /**
   * Sets the current filename
   * @param fname the name of the input file
   */
  public void setFilename(String fname) {
    filename = fname;
  }
  
  /**
   * Creates a source location that starts at the given first token
   * and ends in the last token yet read.
   */
  private SourceInfo _loc(Token first) {
    return new SourceInfo(new File(filename),
                          first.beginLine,
                          first.beginColumn,
                          token.endLine,
                          token.endColumn);
  }
  
  /**
   * Throws a parse exception with the given message at the current token
   * @param message - the message to be thrown
   */
  
  private void _throwParseException(String message) throws ParseException {
    // The error typically occurs on the next token.
    Token t = token;
    if (token.next != null) {
      t = token.next;
    }
    // If a certain token or sequence of tokens is expected, display it.
    ParseException pe = generateParseException();
    throw new CustomParseException(message, t, pe.expectedTokenSequences, tokenImage);
  }
  
  /**
   * Throws a parse exception with the given message at the current token, if the given
   * parse exception was one auto generated by the parser (not one of ours), but not if the
   * message is an <EOF> message, which is passed up to allow continuation of typing
   * @param pe - the previous parse exception thrown
   * @param message - the message to be thrown
   */
  private void _throwParseException(ParseException pe, String message) throws ParseException {
    // Use the embedded error message if thrown from our code, or if ends in EOF
    if (pe instanceof CustomParseException) {
      message = pe.getMessage();
    }
    if(pe.getMessage().indexOf("<EOF>\"") != -1) {
      message = "Encountered Unexpected \"<EOF>\"";
    }
    _throwParseException(message);
  }
  
  /**
   * Creates a primary expression from a refix and a list of suffixes
   * @param prefix   the prefix expression
   * @param suffixes the suffix list built in reverse order
   */
  private static Expression createPrimaryExpression(Expression prefix, List<ExpressionSuffix> suffixes) {
    Iterator<ExpressionSuffix> it = suffixes.iterator();
    if (it.hasNext()) {
      return it.next().createExpression(prefix, it);
    } else {
      if (prefix instanceof CompileTimeQualifiedName) {
        return ((CompileTimeQualifiedName)prefix).createFieldAccess();
      } else if (prefix instanceof CompileTimeExpression) {
        return ((CompileTimeExpression)prefix).createRuntimeExpression();
      } else {
        return prefix;
      }
    }
  }
  
  /**
   * Creates a field declaration
   */
  private FieldDeclaration createFieldDeclaration(ModifierFlags  mf,
                                                  TypeName           typ,
                                                  Token          name,
                                                  Expression     exp,
                                                  int            dim) {
    
    int bl, bc, el, ec, flags = 0;
    
    // Compute the position of the declaration in the source code
    if (mf != null) {
      bl    = mf.beginLine;
      bc    = mf.beginColumn;
      flags = mf.accessFlags;
    } else {
      bl = typ.getBeginLine();
      bc = typ.getBeginColumn();
    }
    
    if (exp != null) {
      el = exp.getEndLine();
      ec = exp.getEndColumn();
    } else {
      el = name.endLine;
      ec = name.endColumn;
    }
    
    // If the field is an array, create an array type node
    if (dim > 0) {
      typ = new ArrayTypeName(typ, dim,
                          filename,
                          typ.getBeginLine(), typ.getBeginColumn(),
                          typ.getEndLine(),   typ.getEndColumn());
    }
    
    return new FieldDeclaration(flags, typ, name.image, exp,
                                filename, bl, bc, el, ec);
  }
  
  /**
   * Creates a variable declaration
   */
  private VariableDeclaration createVariableDeclaration(Token          mf,
                                                        TypeName           typ,
                                                        Token          name,
                                                        Expression     exp,
                                                        int            dim) {
    int bl, bc, el, ec;
    boolean isFinal = false;
    
    // Compute the position of the declaration in the source code
    if (mf != null) {
      bl      = mf.beginLine;
      bc      = mf.beginColumn;
      isFinal = true;
    } else {
      bl = typ.getBeginLine();
      bc = typ.getBeginColumn();
    }
    
    if (exp != null) {
      el = exp.getEndLine();
      ec = exp.getEndColumn();
    } else {
      el = name.endLine;
      ec = name.endColumn;
    }
    
    // If the variable contains an array, create an array type node
    if (dim > 0) {
      typ = new ArrayTypeName(typ, dim,
                          filename,
                          typ.getBeginLine(), typ.getBeginColumn(),
                          typ.getEndLine(),   typ.getEndColumn());
    }
    
    return new VariableDeclaration(isFinal, typ, name.image, exp,
                                   filename, bl, bc, el, ec);
  }
  
  
  private void checkModifiers(int flags, int notAllowed) throws ParseException {
    if(Modifier.isPublic(flags) && Modifier.isPublic(notAllowed))
      _throwParseException("Modifier public is not allowed here");
    if(Modifier.isPrivate(flags) && Modifier.isPrivate(notAllowed))
      _throwParseException("Modifier private is not allowed here");
    if(Modifier.isProtected(flags) && Modifier.isProtected(notAllowed))
      _throwParseException("Modifier protected is not allowed here");
    if(Modifier.isAbstract(flags) && Modifier.isAbstract(notAllowed))
      _throwParseException("Modifier abstract is not allowed here");
    if(Modifier.isFinal(flags) && Modifier.isFinal(notAllowed))
      _throwParseException("Modifier final is not allowed here");
    if(Modifier.isStatic(flags) && Modifier.isStatic(notAllowed))
      _throwParseException("Modifier static is not allowed here");
    if(Modifier.isNative(flags) && Modifier.isNative(notAllowed))
      _throwParseException("Modifier native is not allowed here");
    if(Modifier.isSynchronized(flags) && Modifier.isSynchronized(notAllowed))
      _throwParseException("Modifier synchronized is not allowed here");
    if(Modifier.isTransient(flags) && Modifier.isTransient(notAllowed))
      _throwParseException("Modifier transient is not allowed here");
    if(Modifier.isVolatile(flags) && Modifier.isVolatile(notAllowed))
      _throwParseException("Modifier volatile is not allowed here");
  }
  
  
  /*
   * The classes derived from this one are used for parsing only
   */
  
  abstract class ExpressionSuffix {
    /**
     * Creates an expression node
     * @param prefix the prefix expression
     * @param it     an iterator over the suffixes
     */
    public abstract Expression createExpression(Expression prefix, Iterator<ExpressionSuffix> it);
  }
  
  class DotAllocationSuffix extends ExpressionSuffix {
    /**
     * The allocation expression
     */
    public Allocation expression;
    
    /**
     * Creates a new suffix
     * @param exp the expression
     */
    public DotAllocationSuffix(Allocation exp) {
      expression = exp;
    }
    
    /**
     * Creates an expression node
     * @param prefix the prefix expression
     * @param it     an iterator over the suffixes
     */
    public Expression createExpression(Expression prefix, Iterator<ExpressionSuffix> it) {
      Expression exp = prefix;
      if (it.hasNext()) {
        exp = (it.next()).createExpression(prefix, it);
      } else {
        if (prefix instanceof CompileTimeExpression) {
          exp = ((CompileTimeExpression)prefix).createRuntimeExpression();
        }
      }
      if (expression instanceof SimpleAllocation) {
        SimpleAllocation sa = (SimpleAllocation)expression;
        if(sa instanceof PolymorphicSimpleAllocation){
          return new PolymorphicInnerAllocation
            (exp, sa.getCreationType(), sa.getArguments(), ((PolymorphicSimpleAllocation)sa).getTypeArguments(),
             filename,
             exp.getBeginLine(), exp.getBeginColumn(),
             sa.getEndLine(),    sa.getEndColumn());
        }
        else {
          return new InnerAllocation
            (exp, sa.getCreationType(), sa.getArguments(),
             filename,
             exp.getBeginLine(), exp.getBeginColumn(),
             sa.getEndLine(),    sa.getEndColumn());
        }
      } else {
        ClassAllocation ca = (ClassAllocation)expression;
        if(ca instanceof PolymorphicClassAllocation){
          return new PolymorphicInnerClassAllocation
            (exp, ca.getCreationType(), ca.getArguments(), ca.getMembers(), ((PolymorphicClassAllocation)ca).getTypeArguments(),
             filename,
             exp.getBeginLine(), exp.getBeginColumn(),
             ca.getEndLine(),    ca.getEndColumn());
        }
        else {
          return new InnerClassAllocation
            (exp, ca.getCreationType(), ca.getArguments(), ca.getMembers(),
             filename,
             exp.getBeginLine(), exp.getBeginColumn(),
             ca.getEndLine(),    ca.getEndColumn());
        }
      }
    }
  }
  
  class DotIdentifierSuffix extends ExpressionSuffix {
    /**
     * The identifier
     */
    public Token identifier;
    
    /**
     * Creates a new suffix
     * @param ident the identifier
     */
    public DotIdentifierSuffix(Token ident) {
      identifier = ident;
    }
    
    /**
     * Creates an expression node
     * @param prefix the prefix expression
     * @param it     an iterator over the suffixes
     */
    public Expression createExpression(Expression prefix, Iterator<ExpressionSuffix> it) {
      Expression exp = prefix;
      if (it.hasNext()) {
        exp = it.next().createExpression(prefix, it);
      } else {
        if (prefix instanceof CompileTimeExpression) {
          exp = ((CompileTimeExpression)prefix).createRuntimeExpression();
        }
      }
      return new ObjectFieldAccess
        (exp, identifier.image,
         filename,
         exp.getBeginLine(), exp.getBeginColumn(),
         identifier.endLine, identifier.endColumn);
    }
  }
  
  class ArrayReferenceSuffix extends ExpressionSuffix {
    /**
     * The expression
     */
    public Expression expression;
    
    /**
     * The end line
     */
    public int endLine;
    
    /**
     * The end column
     */
    public int endColumn;
    
    /**
     * Creates a new suffix
     * @param exp the expression
     * @param el  the end line
     * @param ec  the end column
     */
    public ArrayReferenceSuffix(Expression exp, int el, int ec) {
      expression = exp;
      endLine    = el;
      endColumn  = ec;
    }
    
    /**
     * Creates an expression node
     * @param prefix the prefix expression
     * @param it     an iterator over the suffixes
     */
    public Expression createExpression(Expression prefix, Iterator<ExpressionSuffix> it) {
      Expression exp = prefix;
      if (it.hasNext()) {
        exp = it.next().createExpression(prefix, it);
      } else {
        if (prefix instanceof CompileTimeExpression) {
          exp = ((CompileTimeExpression)prefix).createRuntimeExpression();
        }
      }
      return new ArrayAccess
        (exp, expression,
         filename,
         exp.getBeginLine(), exp.getBeginColumn(),
         endLine, endColumn);
    }
  }
  
  class DotThisSuffix extends ExpressionSuffix {
    /**
     * The end line
     */
    public int endLine;
    
    /**
     * The end column
     */
    public int endColumn;
    
    /**
     * Creates a new suffix
     * @param el  the end line
     * @param ec  the end column
     * @param fn  the file name
     */
    public DotThisSuffix(int el, int ec) {
      endLine    = el;
      endColumn  = ec;
    }
    
    /**
     * Creates an expression node
     * @param prefix the prefix expression
     * @param it     an iterator over the suffixes
     */
    public Expression createExpression(Expression prefix, Iterator<ExpressionSuffix> it) {
      Expression exp = prefix;
      if (it.hasNext()) {
        exp = (it.next()).createExpression(prefix, it);
      } else {
        if (prefix instanceof CompileTimeExpression) {
          exp = ((CompileTimeExpression)prefix).createRuntimeExpression();
        }
      }
      if (exp instanceof QualifiedName) {
        return new ThisExpression
          (((QualifiedName)exp).getIdentifiers(),
           filename,
           exp.getBeginLine(), exp.getBeginColumn(),
           endLine, endColumn);
      } else {
        throw new ParseError(reader.getMessage("this.prefix", null),
                             filename,
                             exp.getBeginLine(), exp.getBeginColumn());
      }
    }
  }
  
  class ArgumentsSuffix extends ExpressionSuffix {
    /**
     * The arguments
     */
    public List<Expression> arguments;
    
    /**
     * The type arguments
     */
    public List<TypeName> typeArgs;
    
    /**
     * The end line
     */
    public int endLine;
    
    /**
     * The end column
     */
    public int endColumn;
    
    /**
     * Creates a new argument suffix
     * @param args  the list of argument
     * @param el    the end line
     * @param ec    the end column
     */
    public ArgumentsSuffix(List<Expression> args, List<TypeName> tArgs, int el, int ec) {
      arguments = args;
      typeArgs = tArgs;
      endLine   = el;
      endColumn = ec;
    }
    
    /**
     * Creates an expression node
     * @param prefix the prefix expression
     * @param it     an iterator over the suffixes
     */
    public Expression createExpression(Expression prefix, Iterator<ExpressionSuffix> it) {
      if (it.hasNext()) {
        ExpressionSuffix es = it.next();
        if (es instanceof DotIdentifierSuffix) {
          DotIdentifierSuffix dis = (DotIdentifierSuffix)es;
          Expression exp = prefix;
          if (it.hasNext()) {
            exp = it.next().createExpression(prefix, it);
          } else if (prefix instanceof CompileTimeExpression) {
            exp = ((CompileTimeExpression)prefix).createRuntimeExpression();
          }
          if(typeArgs != null && typeArgs.size() > 0)
            return new PolymorphicObjectMethodCall
            (exp, dis.identifier.image, arguments, typeArgs,
             filename,
             exp.getBeginLine(), exp.getBeginColumn(),
             endLine, endColumn);
          else
            return new ObjectMethodCall
            (exp, dis.identifier.image, arguments,
             filename,
             exp.getBeginLine(), exp.getBeginColumn(),
             endLine, endColumn);
        } else {
          throw new ParseError(reader.getMessage("parameter.list", null),
                               filename,
                               endLine, endColumn);
        }
      } else {
        if (prefix instanceof CompileTimeQualifiedName) {
          // Remove the last identifier from the qualified name
          List<IdentifierToken>  l = ((CompileTimeQualifiedName)prefix).identifiers;
          Token f = (l.get(0)).getToken();
          Token t = (l.remove(l.size()-1)).getToken();
          Expression exp = null;
          if (l.size() >= 1) {
            exp = ((CompileTimeQualifiedName)prefix).
              createRuntimeExpression();
          }
          if(typeArgs != null && typeArgs.size() > 0)
            return new PolymorphicObjectMethodCall(exp, t.image, arguments, typeArgs,
                                                   filename,
                                                   f.beginLine, f.beginColumn,
                                                   endLine,   endColumn);
          else
            return new ObjectMethodCall(exp, t.image, arguments,
                                        filename,
                                        f.beginLine, f.beginColumn,
                                        endLine,   endColumn);
        } else if (prefix instanceof CompileTimeSuperExpression) {
          // Transform the super expression into a super method call
          CompileTimeSuperExpression se = (CompileTimeSuperExpression)prefix;
          if(typeArgs != null && typeArgs.size() > 0)
            return new PolymorphicSuperMethodCall(se.identifier, arguments, typeArgs,
                                                  filename,
                                                  se.getBeginLine(), se.getBeginColumn(),
                                                  endLine,           endColumn);
          else
            return new SuperMethodCall(se.identifier, arguments,
                                       filename,
                                       se.getBeginLine(), se.getBeginColumn(),
                                       endLine,           endColumn);
        } else {
          throw new ParseError(reader.getMessage("parameter.list", null),
                               filename,
                               endLine, endColumn);
        }
      }
    }
  }
  
  interface CompileTimeExpression {
    /**
     * Builds a runtime expression from this compile-time one.
     * This method must only be called when the expression has no suffix.
     */
    Expression createRuntimeExpression();
    
  }
  
  class CompileTimeSuperExpression
    extends Expression implements CompileTimeExpression {
    /**
     * The identifier from the superclass
     */
    public String identifier;
    
    /**
     * Initializes the expression
     * @param ident the identifier from the super class
     * @param bl    the begin line
     * @param bc    the begin column
     * @param el    the end line
     * @param ec    the end column
     */
    public CompileTimeSuperExpression(String ident, int bl, int bc, int el, int ec) {
      super("", bl, bc, el, ec);
      identifier = ident;
    }
    
    /**
     * Builds a runtime expression from this compile-time one.
     * This method must be called when the expression has no suffix
     */
    public Expression createRuntimeExpression() {
      return new SuperFieldAccess(identifier,
                                  filename,
                                  getBeginLine(), getBeginColumn(),
                                  getEndLine(),   getEndColumn());
    }
    
    /**
     * Not used
     */
    public <T> T acceptVisitor(Visitor<T> visitor) {
      return null;
    }
  }
  
  class CompileTimeQualifiedName extends Expression implements CompileTimeExpression {
    /**
     * The identifiers (tokens)
     */
    public List<IdentifierToken> identifiers;
    
    /**
     * Initializes the expression
     * @param ids a list of token
     */
    public CompileTimeQualifiedName(List<IdentifierToken> ids) {
      super("", 0, 0, 0, 0);
      identifiers = ids;
    }
    
    /**
     * Creates a runtime qualified name
     */
    public Expression createFieldAccess() {
      if (identifiers.size() == 1) {
        Token t = (identifiers.get(0)).getToken();
        return new QualifiedName(identifiers,
                                 filename,
                                 t.beginLine, t.beginColumn,
                                 t.endLine,   t.endColumn);
      } else {
        Token f = (identifiers.get(0)).getToken();
        Token t = (identifiers.remove(identifiers.size()-1)).getToken();;
        Token l = (identifiers.get(identifiers.size()-1)).getToken();
        return new ObjectFieldAccess(new QualifiedName(identifiers,
                                                       filename,
                                                       f.beginLine, f.beginColumn,
                                                       l.endLine,   l.endColumn),
                                     t.image, filename,
                                     f.beginLine, f.beginColumn,
                                     t.endLine,   t.endColumn);
      }
    }
    
    /**
     * Builds a runtime expression from this compile-time one.
     * This method must be called when the expression has no suffix
     */
    public Expression createRuntimeExpression() {
      Token first = (identifiers.get(0)).getToken();
      Token last  = (identifiers.get(identifiers.size()-1)).getToken();
      return new QualifiedName(identifiers,
                               filename,
                               first.beginLine, first.beginColumn,
                               last.endLine,    last.endColumn);
    }
    
    /**
     * Not used
     */
    public <T> T acceptVisitor(Visitor<T> visitor) {
      return null;
    }
  }
  
  /**
   * To store modifier flags
   */
  static class ModifierFlags {
    int accessFlags;
    int beginLine;
    int beginColumn;
    
    ModifierFlags(int flags, int bl, int bc) {
      accessFlags = flags;
      beginLine   = bl;
      beginColumn = bc;
    }
  }
  
  /**
   * To store a class body
   */
  static class ClassBody {
    List<Node> list;
    int  endLine;
    int  endColumn;
    
    ClassBody(List<Node> l, int el, int ec) {
      list      = l;
      endLine   = el;
      endColumn = ec;
    }
  }
}
PARSER_END(Parser)
  
  /*
   * The lexical grammar
   */
  
  /* WHITE SPACE */
  
  SKIP :
{
  " "
    | "\t"
    | "\n"
    | "\r"
    | "\f"
}

/* COMMENTS */

  SKIP :
  {
    "//" : IN_SINGLE_LINE_COMMENT
      |
    "#" : IN_SINGLE_LINE_COMMENT
      |
    <"/**" ~["/"]> { input_stream.backup(1); } : IN_FORMAL_COMMENT
      |
    "/*" : IN_MULTI_LINE_COMMENT
  }
  
  <IN_SINGLE_LINE_COMMENT>
  SKIP :
  {
    <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
  }
  
  <IN_FORMAL_COMMENT>
  SKIP :
  {
    <FORMAL_COMMENT: "*/" > : DEFAULT
  }
  
  <IN_MULTI_LINE_COMMENT>
  SKIP :
  {
    <MULTI_LINE_COMMENT: "*/" > : DEFAULT
  }
  
  <IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
  SKIP :
  {
    < ~[] >
  }
  
  /* RESERVED WORDS AND LITERALS */
  
  TOKEN :
  {
    < ABSTRACT: "abstract" >
    | < ASSERT: "assert" >
    | < BOOLEAN: "boolean" >
    | < BREAK: "break" >
    | < BYTE: "byte" >
    | < CASE: "case" >
    | < CATCH: "catch" >
    | < CHAR: "char" >
    | < CLASS: "class" >
    | < CONST: "const" >
    | < CONTINUE: "continue" >
    | < _DEFAULT: "default" >
    | < DO: "do" >
    | < DOUBLE: "double" >
    | < ELSE: "else" >
    | < ENUM: "enum" >
    | < EXTENDS: "extends" >
    | < FALSE: "false" >
    | < FINAL: "final" >
    | < FINALLY: "finally" >
    | < FLOAT: "float" >
    | < FOR: "for" >
    | < GOTO: "goto" >
    | < IF: "if" >
    | < IMPLEMENTS: "implements" >
    | < IMPORT: "import" >
    | < INSTANCEOF: "instanceof" >
    | < INT: "int" >
    | < INTERFACE: "interface" >
    | < LONG: "long" >
    | < NATIVE: "native" >
    | < NEW: "new" >
    | < NULL: "null" >
    | < PACKAGE: "package">
    | < PRIVATE: "private" >
    | < PROTECTED: "protected" >
    | < PUBLIC: "public" >
    | < RETURN: "return" >
    | < SHORT: "short" >
    | < STATIC: "static" >
    | < SUPER: "super" >
    | < SWITCH: "switch" >
    | < SYNCHRONIZED: "synchronized" >
    | < THIS: "this" >
    | < THROW: "throw" >
    | < THROWS: "throws" >
    | < TRANSIENT: "transient" >
    | < TRUE: "true" >
    | < TRY: "try" >
    | < VOID: "void" >
    | < VOLATILE: "volatile" >
    | < WHILE: "while" >
  }
  
  /* LITERALS */
  
  TOKEN :
  {
    < INTEGER_LITERAL:
      <DECIMAL_LITERAL>
      | <HEX_LITERAL>
      | <OCTAL_LITERAL>
      >
      |
    < LONG_LITERAL:
      <DECIMAL_LITERAL> ["l","L"]
      | <HEX_LITERAL>     ["l","L"]
      | <OCTAL_LITERAL>   ["l","L"]
      >
      |
    < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
      |
    < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
      |
    < #OCTAL_LITERAL: "0" (["0"-"7"])* >
      |
    < FLOAT_LITERAL:
      (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? ["f","F"]
      | "." (["0"-"9"])+ (<EXPONENT>)? ["f","F"]
      | (["0"-"9"])+ <EXPONENT> ["f","F"]
      | (["0"-"9"])+ (<EXPONENT>)? ["f","F"]
      >
      |
      < DOUBLE_LITERAL:
      (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["d","D"])?
      | "." (["0"-"9"])+ (<EXPONENT>)? (["d","D"])?
      | (["0"-"9"])+ <EXPONENT> (["d","D"])?
      | (["0"-"9"])+ (<EXPONENT>)? ["d","D"]
      >
      |
      < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
      |
      < CHARACTER_LITERAL:
      "'"
      (   (~["'","\\","\n","\r"])
         | ("\\"
              ( ["n","t","b","r","f","\\","'","\""]
                 | ["0"-"7"] ( ["0"-"7"] )?
                 | ["0"-"3"] ["0"-"7"] ["0"-"7"]
                 )
              )
         )
      "'"
      >
      |
      < STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
         | ("\\"
              ( ["n","t","b","r","f","\\","'","\""]
                 | ["0"-"7"] ( ["0"-"7"] )?
                 | ["0"-"3"] ["0"-"7"] ["0"-"7"]
                 )
              )
         )*
      "\""
      >
  }
  
  /* IDENTIFIERS */
  
  TOKEN :
  {
    < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >
      |
    < #LETTER:
      [
       "\u0024",
       "\u0041"-"\u005a",
       "\u005f",
       "\u0061"-"\u007a",
       "\u00c0"-"\u00d6",
       "\u00d8"-"\u00f6",
       "\u00f8"-"\u00ff",
       "\u0100"-"\u1fff",
       "\u3040"-"\u318f",
       "\u3300"-"\u337f",
       "\u3400"-"\u3d2d",
       "\u4e00"-"\u9fff",
       "\uf900"-"\ufaff"
         ]
      >
      |
    < #DIGIT:
      [
       "\u0030"-"\u0039",
       "\u0660"-"\u0669",
       "\u06f0"-"\u06f9",
       "\u0966"-"\u096f",
       "\u09e6"-"\u09ef",
       "\u0a66"-"\u0a6f",
       "\u0ae6"-"\u0aef",
       "\u0b66"-"\u0b6f",
       "\u0be7"-"\u0bef",
       "\u0c66"-"\u0c6f",
       "\u0ce6"-"\u0cef",
       "\u0d66"-"\u0d6f",
       "\u0e50"-"\u0e59",
       "\u0ed0"-"\u0ed9",
       "\u1040"-"\u1049"
         ]
      >
  }
  
  /* SEPARATORS */
  
  TOKEN :
  {
    < LPAREN: "(" >
    | < RPAREN: ")" >
    | < LBRACE: "{" >
    | < RBRACE: "}" >
    | < LBRACKET: "[" >
    | < RBRACKET: "]" >
    | < SEMICOLON: ";" >
    | < COMMA: "," >
    | < DOT: "." >
  }
  
  /* OPERATORS */
  
  TOKEN :
  {
    < ASSIGN: "=" >
    | < GREATER_THAN: ">" >
    | < LESS: "<" >
    | < BANG: "!" >
    | < TILDE: "~" >
    | < HOOK: "?" >
    | < COLON: ":" >
    | < EQUAL: "==" >
    | < LESS_OR_EQUAL: "<=" >
    | < GREATER_OR_EQUAL: ">=" >
    | < NOT_EQUAL: "!=" >
    | < CONDITIONAL_OR: "||" >
    | < CONDITIONAL_AND: "&&" >
    | < INCREMENT: "++" >
    | < DECREMENT: "--" >
    | < PLUS: "+" >
    | < MINUS: "-" >
    | < STAR: "*" >
    | < SLASH: "/" >
    | < BITWISE_AND: "&" >
    | < BITWISE_OR: "|" >
    | < XOR: "^" >
    | < REMAINDER: "%" >
    | < LEFT_SHIFT: "<<" >
      /* | < RIGHT_SIGNED_SHIFT: ">>" >
       | < RIGHT_UNSIGNED_SHIFT: ">>>" > */
    | < PLUS_ASSIGN: "+=" >
    | < MINUS_ASSIGN: "-=" >
    | < STAR_ASSIGN: "*=" >
    | < SLASH_ASSIGN: "/=" >
    | < AND_ASSIGN: "&=" >
    | < OR_ASSIGN: "|=" >
    | < XOR_ASSIGN: "^=" >
    | < REMAINDER_ASSIGN: "%=" >
    | < LEFT_SHIFT_ASSIGN: "<<=" >
    | < RIGHT_SIGNED_SHIFT_ASSIGN: ">>=" >
    | < RIGHT_UNSIGNED_SHIFTASSIGN: ">>>=" >
    | < VAR_ARGS:  "...">
  }
  
  TOKEN : /* OPERATORS, from Generics Preprocessor  */
  {
    /*  < ASSIGN: "=" >
     | < GT: ">" >
     | < LT: "<" >
     | < BANG: "!" >
     | < TILDE: "~" >
     | < HOOK: "?" >
     | < COLON: ":" >
     | < EQ: "==" >
     | < LE: "<=" >
     | < GE: ">=" >
     | < NE: "!=" >
     | < SC_OR: "||" >
     | < SC_AND: "&&" >
     | < INCR: "++" >
     | < DECR: "--" >
     | < PLUS: "+" >
     | < MINUS: "-" >
     | < STAR: "*" >
     | < SLASH: "/" >
     | < BIT_AND: "&" >
     | < BIT_OR: "|" >
     | < XOR: "^" >
     | < REM: "%" >
     | < LSHIFT: "<<" >
     | */
    < RSIGNEDSHIFT: ">>" >
    {
      matchedToken.kind = RSSHIFT1;
      matchedToken.image = ">@1";
      matchedToken.next = new Token();
      matchedToken.next.kind = RSSHIFT2;
      matchedToken.next.image = ">@2";
    }
    | < RUNSIGNEDSHIFT: ">>>" >
    {
      matchedToken.image = ">`1";
      matchedToken.kind = RUSHIFT1;
      matchedToken.next = new Token();
      matchedToken.next.kind = RUSHIFT2;
      matchedToken.next.image = ">`2";
      matchedToken.next.next = new Token();
      matchedToken.next.next.kind = RUSHIFT3;
      matchedToken.next.next.image = ">`3";
    }
    | < RSSHIFT1: ">@1" >
    | < RSSHIFT2: ">@2" >
    | < RUSHIFT1: ">`1" >
    | < RUSHIFT2: ">`2" >
    | < RUSHIFT3: ">`3" >
      /*| < PLUSASSIGN: "+=" >
       | < MINUSASSIGN: "-=" >
       | < STARASSIGN: "*=" >
       | < SLASHASSIGN: "/=" >
       | < ANDASSIGN: "&=" >
       | < ORASSIGN: "|=" >
       | < XORASSIGN: "^=" >
       | < REMASSIGN: "%=" >
       | < LSHIFTASSIGN: "<<=" >
       | < RSIGNEDSHIFTASSIGN: ">>=" >
       | < RUNSIGNEDSHIFTASSIGN: ">>>=" >*/
  }
  
  JAVACODE
    void _errorChar(char c) {
    _throwParseException("'" + c + "' expected.");
  }
  /*
   * The syntactic grammar
   */
  
  // Productions for the intepreter ////////////////////////////////////////////////
  
  /**
   * Parses input stream. This production is
   * not a Java language rule. It is used by DynamicJava.
   * @return a list of nodes (possibly empty)
   * @see koala.dynamicjava.tree.Node
   */
  List<Node> parseStream() :
  {
    List<Node> list = new LinkedList<Node>();
    List<Node> l = new LinkedList<Node>();
    Node root = null;
  }
  {
    (  LOOKAHEAD(topLevelStatementLookahead())
       l = topLevelStatement()
       { list.addAll(l);  l.clear(); }
    )*
      
      [ root = expression() [";"] { list.add(root); } ]
        <EOF>
      {
        return list;
      }
  }
  
  /**
   * Parses an item of the input stream. This production is
   * not a Java language rule. It is used by DynamicJava.
   * @return a list of nodes (possibly empty)
   * @see koala.dynamicjava.tree.Node
   */
  List<Node> topLevelStatement() :
  {
    Node root = null;
    List<Node> l = new LinkedList<Node>();
  }
  {
    try {
      (
       root = singleLookaheadStatement()
         | LOOKAHEAD(2)
         root=synchronizedStatement()
         | LOOKAHEAD(2)
         root=labeledStatement()
         | LOOKAHEAD( methodDeclarationLookahead() )
         root=methodDeclaration()
         | LOOKAHEAD([ "final" ] typeLookahead() <IDENTIFIER>)
         l=localVariableDeclaration() (";" | <EOF>)
         | LOOKAHEAD(typeDeclarationLookahead())
         root=typeDeclaration()
         | LOOKAHEAD(expression())
         root=expression() ";"
         )
      {
        if (root != null) {
          l.add(root);
        }
        return l;
      }
    }
    catch(ParseException pe) {
      _throwParseException(pe, "Invalid Stream Item");
    }
  }
  
  /**
   * Parses one top level statement which requires a lookahed of one.
   * This production is not a Java language rule. It is used by DynamicJava.
   *
   * @return a node
   * @see koala.dynamicjava.tree.Node
   */
  Node singleLookaheadStatement() :
  {
    Node node;
  }
  {
    try {
      (    /** Originally separate, added as they are top level statements that require lookahead of one */
       node=packageDeclaration()
         | node=importDeclaration()
         | node=block()
         | node=emptyStatement()
         | node=ifStatement()
         | node=assertStatement()
         | node=whileStatement()
         | node=doStatement()
         | node=switchStatement()
         | node=forStatement()
         | node=breakStatement()
         | node=continueStatement()
         | node=returnStatement()
         | node=throwStatement()
         | node=tryStatement()
         )
      {
        return node;
      }
    }
    catch (ParseException pe) {
      _throwParseException(pe, "Invalid statement");
    }
  }
  
  // Productions for Packages ////////////////////////////////////////////////////////
  
  /**
   * Parses a Java compilation unit
   * @return a list of nodes (possibly empty)
   * @see koala.dynamicjava.tree.Node
   */
  List<Node> parseCompilationUnit() :
  {
    List<Node> list = new LinkedList<Node>();
    Node node;
  }
  {
    [ node=packageDeclaration()
       {
      list.add(node);
    }
     ]
       ( node=importDeclaration()
          {
       list.add(node);
     }
     )*
       ( ( node=typeDeclaration()
            {
       list.add(node);
     }
          | ";" )
          )*
            <EOF>
          {
            return list;
          }
  }
  
  /**
   * Parses a package declaration
   * @see koala.dynamicjava.tree.PackageDeclaration
   */
  PackageDeclaration packageDeclaration() :
  {
    ReferenceTypeName name = null;
    Token t1, t2;
  }
  {
    try {
      t1="package" [ name=ReferenceTypeName() ] (t2=";" | t2=<EOF>)
      {
        if(name instanceof GenericReferenceTypeName){
          _throwParseException("Package names cannot be parameterized.");
        }
        if(name == null) {
          _throwParseException("Empty Package name");
        }
        return new PackageDeclaration(name.getRepresentation(),
                                      filename,
                                      t1.beginLine, t1.beginColumn,
                                      t2.endLine,   t2.endColumn);
      }
    }
    catch(ParseException pe) {
      _throwParseException(pe,"Invalid Package Declaration");
    }
  }
  
  /**
   * Parses an import declaration
   * @see koala.dynamicjava.tree.ImportDeclaration
   */
  ImportDeclaration importDeclaration() :
  {
    ReferenceTypeName name = null;
    Token star = null;
    Token t1, t2;
    Token sttic = null;
  }
  {
    try {
      t1="import" [sttic="static"] [name=ReferenceTypeName()] ["." star="*"] (t2=";" | t2=<EOF>)
      {
        if(name instanceof GenericReferenceTypeName){
          _throwParseException("Import names cannot be parameterized.");
        }
        if(name == null) {
          _throwParseException("Missing name - Cannot import");
        }
        return new ImportDeclaration(name.getRepresentation(), star != null, sttic != null,
                                     filename,
                                     t1.beginLine, t1.beginColumn,
                                     t2.endLine,   t2.endColumn);
      }
    }
    catch(ParseException pe) {
      _throwParseException(pe,"Invalid Import Declaration");
    }
  }
  
  /**
   * Parses a top level type declaration
   * @see koala.dynamicjava.tree.TypeDeclaration
   */
  TypeDeclaration typeDeclaration() :
  {
    TypeDeclaration node;
    int modifiers;
  }
  {
    try {
      (    LOOKAHEAD(classDeclarationLookahead())
         node=classDeclaration()
         | LOOKAHEAD(enumDeclarationLookahead())
         node=enumDeclaration()
         | LOOKAHEAD(interfaceDeclarationLookahead())
         node=interfaceDeclaration()
         )
      {
        //Handles modifiers not allowed at the top level
        checkModifiers(node.getAccessFlags(), Modifier.STATIC | Modifier.PRIVATE | Modifier.PROTECTED);
        return node;
      }
    }
    catch(ParseException pe) {
      _throwParseException(pe,"invalid declaration");
    }
  }
  
  // Productions for Names ////////////////////////////////////////////////////////
  
  /**
   * Parses a name
   * @return a list of tree token
   * @see koala.dynamicjava.parser.wrapper.TreeToken
   */
  List<IdentifierToken> name() :
  {
    Token id;
    List<IdentifierToken>  list = new LinkedList<IdentifierToken>();
  }
  {
    id=<IDENTIFIER>
    {
      list.add(new TreeToken(id));
    }
    ( LOOKAHEAD(2)
       "." id=<IDENTIFIER>
     {
      list.add(new TreeToken(id));
    }
    )*
    {
      return list;
    }
  }
  
  // Production for a ReferenceTypeName ////////////////////////////////////////////////////////
  ReferenceTypeName ReferenceTypeName() :
  {
    Token id = null;
    List<IdentifierToken> list = new LinkedList<IdentifierToken>();
    List<TypeName> typeArgs = new LinkedList<TypeName>();
    List<List<? extends TypeName>> allTypeArgs = new LinkedList<List<? extends TypeName>>();
  }
  {
    try{
      id=<IDENTIFIER> [LOOKAHEAD(TypeArguments()) typeArgs = TypeArguments() ]
      {
        list.add(new TreeToken(id));
        allTypeArgs.add( typeArgs );
        typeArgs = new LinkedList<TypeName>();
      }
      ( LOOKAHEAD("." <IDENTIFIER>) "." id=<IDENTIFIER>  [LOOKAHEAD(TypeArguments()) typeArgs = TypeArguments() ]
         {
        list.add(new TreeToken(id));
        allTypeArgs.add( typeArgs );
        typeArgs = new LinkedList<TypeName>();
      }
      )*
        
      {
        IdentifierToken f  = list.get(0);
        IdentifierToken l  = list.get(list.size()-1);
        boolean Parameterized = false;
        for( int i = 0; i < allTypeArgs.size(); i++ ){
          List<? extends TypeName> targs = allTypeArgs.get(i);
          if(targs.size() > 0) {
            Parameterized = true;
            break;
          }
        }
        if(!Parameterized){
          if(TypeParamsMap.containsKey(TreeUtilities.listToName(list))){
            return TypeParamsMap.get(TreeUtilities.listToName(list));
          } else if(GenericTypesEnv.contains(TreeUtilities.listToName(list))){
            return GenericTypesEnv.lookup(TreeUtilities.listToName(list));
          } else {
            return new ReferenceTypeName(list,
                                     filename,
                                     f.beginLine(), f.beginColumn(),
                                     l.endLine(),   l.endColumn());
          }
        } else {
          return new GenericReferenceTypeName(list,
                                          filename,
                                          f.beginLine(), f.beginColumn(),
                                          l.endLine(), l.endColumn(),
                                          allTypeArgs);
        }
      }
    }
    catch(ParseException pe) {
      _throwParseException(pe,"Invalid Reference name");
    }
  }
  
  /**
   * Parses a comma separated list of ReferenceTypeName names
   * @return a list of ReferenceTypeName
   * @see koala.dynamicjava.tree.ReferenceTypeName
   */
  List<? extends ReferenceTypeName> ReferenceTypeNameList() :
  {
    List<ReferenceTypeName> list = new LinkedList<ReferenceTypeName>();
    ReferenceTypeName obj;
  }
  {
    obj=ReferenceTypeName()
    {
      list.add(obj);
    }
    ( "," obj=ReferenceTypeName()
       {
      list.add(obj);
    }
    )*
    {
      return list;
    }
  }
  
  // Productions for Classes //////////////////////////////////////////////////////
  
  // Productions for Class Declaration ============================================
  
  /**
   * Parses a class declaration
   * @see koala.dynamicjava.tree.ClassDeclaration
   */
  ClassDeclaration classDeclaration() :
  {
    ClassDeclaration cd;
    ModifierFlags    md;
  }
  {
    md=modifiers() cd=unmodifiedClassDeclaration(md)
    {
      if(md != null)
        checkModifiers(md.accessFlags, Modifier.NATIVE | Modifier.SYNCHRONIZED | Modifier.TRANSIENT | Modifier.VOLATILE);
      return cd;
    }
  }
  
  /**
   * Used internally to parse a modifier
   */
  ModifierFlags modifiers() :
  {
    Token t;
    int   flags = 0;
    Token ft    = null;
  }
  {
    ( t="abstract"
       {
      if (ft == null) {
        ft = t;
      } else if ((flags & Modifier.ABSTRACT) != 0) {
        throw new ParseError(reader.getMessage("abstract.abstract", null),
                             filename,
                             t.beginLine, t.beginColumn);
      } else if ((flags & Modifier.FINAL) != 0) {
        throw new ParseError(reader.getMessage("abstract.final", null),
                             filename,
                             t.beginLine, t.beginColumn);
      }
      flags |= Modifier.ABSTRACT;
    }
     | t="final"
       {
       if (ft == null) {
         ft = t;
       } else if ((flags & Modifier.FINAL) != 0) {
         throw new ParseError(reader.getMessage("final.final", null),
                              filename,
                              t.beginLine, t.beginColumn);
       } else if ((flags & Modifier.ABSTRACT) != 0) {
         throw new ParseError(reader.getMessage("abstract.final", null),
                              filename,
                              t.beginLine, t.beginColumn);
       }
       flags |= Modifier.FINAL;
     }
     | t="public"
       {
       if (ft == null) {
         ft = t;
       } else if ((flags & Modifier.PUBLIC) != 0) {
         throw new ParseError(reader.getMessage("public.public", null),
                              filename,
                              t.beginLine, t.beginColumn);
       } else if ((flags & Modifier.PROTECTED) != 0) {
         throw new ParseError(reader.getMessage("public.protected", null),
                              filename,
                              t.beginLine, t.beginColumn);
       } else if ((flags & Modifier.PRIVATE) != 0) {
         throw new ParseError(reader.getMessage("public.private", null),
                              filename,
                              t.beginLine, t.beginColumn);
       }
       
       flags |= Modifier.PUBLIC;
     }
     | t="protected"
       {
       if (ft == null) {
         ft = t;
       } else if ((flags & Modifier.PROTECTED) != 0) {
         throw new ParseError(reader.getMessage("protected.protected", null),
                              filename,
                              t.beginLine, t.beginColumn);
       } else if ((flags & Modifier.PUBLIC) != 0) {
         throw new ParseError(reader.getMessage("public.protected", null),
                              filename,
                              t.beginLine, t.beginColumn);
       } else if ((flags & Modifier.PRIVATE) != 0) {
         throw new ParseError(reader.getMessage("protected.private", null),
                              filename,
                              t.beginLine, t.beginColumn);
       }
       flags |= Modifier.PROTECTED;
     }
     | t="private"
       {
       if (ft == null) {
         ft = t;
       }  else if ((flags & Modifier.PRIVATE) != 0) {
         throw new ParseError(reader.getMessage("private.private", null),
                              filename,
                              t.beginLine, t.beginColumn);
       } else if ((flags & Modifier.PUBLIC) != 0) {
         throw new ParseError(reader.getMessage("public.private", null),
                              filename,
                              t.beginLine, t.beginColumn);
       } else if ((flags & Modifier.PROTECTED) != 0) {
         throw new ParseError(reader.getMessage("protected.private", null),
                              filename,
                              t.beginLine, t.beginColumn);
       }
       flags |= Modifier.PRIVATE;
     }
     | t="transient"
       {
       if (ft == null) {
         ft = t;
       } else if ((flags & Modifier.TRANSIENT) != 0) {
         throw new ParseError(reader.getMessage("transient.transient", null),
                              filename,
                              t.beginLine, t.beginColumn);
       }
       flags |= Modifier.TRANSIENT;
     }
     | t="volatile"
       {
       if (ft == null) {
         ft = t;
       } else if ((flags & Modifier.VOLATILE) != 0) {
         throw new ParseError(reader.getMessage("volatile.volatile", null),
                              filename,
                              t.beginLine, t.beginColumn);
       }
       flags |= Modifier.VOLATILE;
     }
     | t="native"
       {
       if (ft == null) {
         ft = t;
       } else if ((flags & Modifier.NATIVE) != 0) {
         throw new ParseError(reader.getMessage("native.native", null),
                              filename,
                              t.beginLine, t.beginColumn);
       }  else if ((flags & Modifier.ABSTRACT) != 0) {
         throw new ParseError(reader.getMessage("abstract.native", null),
                              filename,
                              t.beginLine, t.beginColumn);
       }
       flags |= Modifier.NATIVE;
     }
     | t="static"
       {
       if (ft == null) {
         ft = t;
       } else if ((flags & Modifier.STATIC) != 0) {
         throw new ParseError(reader.getMessage("static.static", null),
                              filename,
                              t.beginLine, t.beginColumn);
       }
       flags |= Modifier.STATIC;
     }
     | t="synchronized"
       {
       if (ft == null) {
         ft = t;
       } else if ((flags & Modifier.SYNCHRONIZED) != 0) {
         throw new ParseError(reader.getMessage("synchronized.synchronized", null),
                              filename,
                              t.beginLine, t.beginColumn);
       }
       flags |= Modifier.SYNCHRONIZED;
     }
     )*
     {
       return (ft == null)
         ? null
         : new ModifierFlags(flags, ft.beginLine, ft.beginColumn);
     }
  }
  
  /**
   * Parses a class declaration without modifier
   * @see koala.dynamicjava.tree.ClassDeclaration
   */
  ClassDeclaration unmodifiedClassDeclaration(ModifierFlags mf) :
  {
    Token t;
    Token id;
    TypeParameter[] typeParameters = null;
    ReferenceTypeName  ext  = null;
    List<? extends ReferenceTypeName> impl = null;
    ClassBody body;
  }
  {
    t="class" id=<IDENTIFIER>
      [ typeParameters = TypeParameters() ]
      [ "extends" ext=ReferenceTypeName() ] [ "implements" impl=ReferenceTypeNameList() ]
      body=classBody()
    {
      if (typeParameters != null){
        GenericTypesEnv = GenericTypesEnv.getRest(); // pop added type params
        if (mf == null) {
          return new GenericClassDeclaration(0, id.image, ext, impl, body.list,
                                             filename,
                                             t.beginLine,  t.beginColumn,
                                             body.endLine, body.endColumn, typeParameters);
        } else {
          return new GenericClassDeclaration(mf.accessFlags, id.image, ext, impl, body.list,
                                             filename,
                                             mf.beginLine, mf.beginColumn,
                                             body.endLine, body.endColumn, typeParameters);
        }
      }
      else {
        if (mf == null) {
          return new ClassDeclaration(0, id.image, ext, impl, body.list,
                                      filename,
                                      t.beginLine,  t.beginColumn,
                                      body.endLine, body.endColumn);
        } else {
          return new ClassDeclaration(mf.accessFlags, id.image, ext, impl, body.list,
                                      filename,
                                      mf.beginLine, mf.beginColumn,
                                      body.endLine, body.endColumn);
        }
      }
    }
  }
  
  /**
   * Used internally to parse the body of a class
   */
  ClassBody classBody() :
  {
    Token t;
    List<Node> list = new LinkedList<Node>();
    List<Node> decl;
  }
  {
    try {
      "{"
        (
         decl=classBodyDeclaration()
           {
        list.addAll(decl);
      }
      )*
        t="}"
      {
        return new ClassBody(list, t.endLine, t.endColumn);
      }
    }
    catch (ParseException pe) {
      _throwParseException(pe,"Invalid class body");
    }
  }
  
  /**
   * Parses one declaration in the body of a class.
   * @return a list of node because one field declaration can
   *         contain multiple declarations.
   * @see koala.dynamicjava.tree.Node
   */
  List<Node> classBodyDeclaration() :
  {
    Node node = null;
    List<Node> list = new LinkedList<Node>();
  }
  {
    try {
      ( LOOKAHEAD(2)
         node=initializer()
         |
       LOOKAHEAD( classDeclarationLookahead())
         node=classDeclaration()
         |
       LOOKAHEAD( enumDeclarationLookahead())
         node=enumDeclaration()
         |
       LOOKAHEAD( interfaceDeclarationLookahead() )
         node=interfaceDeclaration()
         |
       LOOKAHEAD( constructorDeclarationLookahead() )
         node=constructorDeclaration()
         |
       LOOKAHEAD( methodDeclarationLookahead() )
         node=methodDeclaration()
         |
       list=fieldDeclaration()
         |
       ";"
         )
      {
        if (node != null) {
          list.add(node);
        }
        return list;
      }
    }
    catch (ParseException pe) {
      _throwParseException(pe,"Invalid Member Declaration");
    }
  }
  
  
  // Productions for Field Declaration ============================================
  
  /**
   * Parses a field declaration.
   * @return a list of field declaration because one field declaration can
   *         contain multiple declarations.
   * @see koala.dynamicjava.tree.FieldDeclaration
   */
  List<Node> fieldDeclaration() :
  {
    ModifierFlags mf;
    TypeName          typ;
    Token         id;
    int           dim  = 0;
    Expression    exp  = null;
    List<Node>    list = new LinkedList<Node>();
  }
  {
    try
    {
      mf=modifiers()
        typ=type() id=<IDENTIFIER>
        ( "[" "]" { dim++; } )*
          [ "=" exp=variableInitializer() ]
        {
          if(mf != null)
            checkModifiers(mf.accessFlags,Modifier.ABSTRACT | Modifier.NATIVE | Modifier.SYNCHRONIZED);
          list.add(createFieldDeclaration(mf, typ, id, exp, dim));
        }
        ( "," { dim = 0; exp = null; }
         id=<IDENTIFIER>
         ( "[" "]" { dim++; } )*
         [ "=" exp=variableInitializer() ]
           {
           list.add(createFieldDeclaration(mf, typ, id, exp, dim));
         }
         )* ";"
         {
           return list;
         }
    }
    catch (ParseException pe){
      _throwParseException(pe, "Invalid Field Declaration");
    }
    
  }
  
  // Productions for Method Declaration ===========================================
  
  /**
   * Parses a method declaration
   * @see koala.dynamicjava.tree.MethodDeclaration
   */
  MethodDeclaration methodDeclaration() :
  {
    MethodDeclaration md;
    ModifierFlags     mf;
    int               bl;
    int               bc;
    int               flags = 0;
    TypeParameter[]   typeParameters = null;
    TypeName              typ;
    Token             id;
    int               dim = 0;
    List<FormalParameter> params;
    List<? extends ReferenceTypeName> exceptions = new LinkedList<ReferenceTypeName>();
    Node              body = null;
  }
  {
    try {
      mf=modifiers()
        [ typeParameters = TypeParameters() ]
        typ=resultType()
        id=<IDENTIFIER>
        params=formalParameters()
        ( "[" "]" { dim++; } )*
          [ "throws" exceptions=ReferenceTypeNameList() ]
          ( body=block() | body=emptyStatement() )
        {
          if (mf != null) {
            checkModifiers(mf.accessFlags, Modifier.TRANSIENT | Modifier.VOLATILE);
            bl    = mf.beginLine;
            bc    = mf.beginColumn;
            flags = mf.accessFlags;
          } else {
            bl = typ.getBeginLine();
            bc = typ.getBeginColumn();
          }
          if (dim > 0) {
            typ = new ArrayTypeName(typ, dim,
                                filename,
                                typ.getBeginLine(), typ.getBeginColumn(),
                                typ.getEndLine(),   typ.getEndColumn());
          }
          if(lastFormalParameterIsVarArgs) flags |= 0x00000080; // java.lang.reflect.Modifier.VARARGS == 0x00000080 /**/
          
          if (typeParameters == null){
            return new MethodDeclaration(flags, typ, id.image, params,
                                         exceptions,
                                         (body instanceof BlockStatement) ?
                                           (BlockStatement)body : null,
                                         filename,
                                         bl, bc, body.getEndLine(), body.getEndColumn());
          } else {
            GenericTypesEnv = GenericTypesEnv.getRest(); // pop added type params
            return new PolymorphicMethodDeclaration(flags, typ, id.image, params,
                                                    exceptions,
                                                    (body instanceof BlockStatement) ?
                                                      (BlockStatement)body : null,
                                                    filename,
                                                    bl, bc, body.getEndLine(), body.getEndColumn(),
                                                    typeParameters);
          }
        }
    }
    catch(ParseException pe) {
      _throwParseException(pe, "Invalid method declaration");
    }
  }
  
  /**
   * Parses formal parameters of the form '(param, param, ...)'
   * @see koala.dynamicjava.tree.FormalParameter
   */
  List<FormalParameter> formalParameters() :
  {
    List<FormalParameter> list = new LinkedList<FormalParameter>();
    FormalParameter node;
    FormalParameter lastParam = null;
  }
  {
    try
    {
      "("
        
        [  
         ( LOOKAHEAD(formalParameterLookahead() ",")  node=formalParameter() "," {
        list.add(node);
      }
      )*   
         (LOOKAHEAD(varArgsFormalParameterLookahead() ")") lastParam = varArgsFormalParameter() 
            { lastFormalParameterIsVarArgs = true; } | 
          LOOKAHEAD(formalParameterLookahead() ")") lastParam = formalParameter()
            { lastFormalParameterIsVarArgs = false; } )
           ] ")"
            {
              if(lastParam != null) {
                list.add(lastParam);
              }
              return list;
            }
    }
    catch(ParseException pe) {
      _throwParseException(pe, "Invalid formal parameters");
    }
  }
  
  /**
   * Parses one formal parameter
   * @see koala.dynamicjava.tree.FormalParameter
   */
  FormalParameter formalParameter() :
  {
    TypeName  typ;
    Token id;
    Token f   = null;
    int   dim = 0;
  }
  {
    try
    {
      [ f="final" ] typ=type() id=<IDENTIFIER> ( "[" "]" { dim++; } )*
      {
        if (dim > 0) {
          typ = new ArrayTypeName(typ, dim,
                              filename,
                              typ.getBeginLine(), typ.getBeginColumn(),
                              typ.getEndLine(),   typ.getEndColumn());
        }
        return new FormalParameter(f != null, typ, id.image,
                                   filename,
                                   (f != null) ? f.beginLine   : typ.getBeginLine(),
                                   (f != null) ? f.beginColumn : typ.getBeginColumn(),
                                   id.endLine, id.endColumn);
      }
    }
    catch(ParseException pe) {
      _throwParseException(pe, "Invalid formal parameter");
    }
  }
  
  /**
   * Parses a varargs formal parameter
   * @see koala.dynamicjava.tree.FormalParameter
   */
  FormalParameter varArgsFormalParameter() :
  {
    TypeName  typ;
    Token id;
    Token f   = null;
  }
  {
    try
    {
      [ f="final" ] typ=type() <VAR_ARGS> id=<IDENTIFIER>
      {
        // convert the type of the formal parameter to be an array
        typ = new ArrayTypeName(typ, 1,
                            filename,
                            typ.getBeginLine(), typ.getBeginColumn(),
                            typ.getEndLine(),   typ.getEndColumn());
        return new FormalParameter(f != null, typ, id.image,
                                   filename,
                                   (f != null) ? f.beginLine   : typ.getBeginLine(),
                                   (f != null) ? f.beginColumn : typ.getBeginColumn(),
                                   id.endLine, id.endColumn);
      }
    }
    catch(ParseException pe) {
      _throwParseException(pe, "Invalid variable arguments formal parameter");
    }
  }
  
  
  // Production for Initializer ===================================================
  
  /**
   * Parses one initializer
   * @see koala.dynamicjava.tree.Initializer
   */
  Initializer initializer() :
  {
    Token t = null;
    BlockStatement node;
  }
  {
    [ t="static" ] node=block()
    {
      if (t == null) {
        return new InstanceInitializer(node,
                                       filename,
                                       node.getBeginLine(), node.getEndColumn(),
                                       node.getEndLine(), node.getEndColumn());
      } else {
        return new ClassInitializer(node,
                                    filename,
                                    t.beginLine, t.beginColumn,
                                    node.getEndLine(), node.getEndColumn());
      }
    }
  }
  
  // Productions for Constructor Declaration ======================================
  
  /**
   * Parses a constructor declaration
   * @see koala.dynamicjava.tree.ConstructorDeclaration
   */
  ConstructorDeclaration constructorDeclaration() :
  {
    Token                 t = null;
    ModifierFlags         mf;
    int                   flag = 0;
    Token                 id;
    TypeParameter[]   typeParameters = null;
    List<FormalParameter> params;
    List<? extends ReferenceTypeName> exceptions = new LinkedList<ReferenceTypeName>();
    ConstructorInvocation ci = null;
    List<Node>            stmt;
    List<Node>            stmts = new LinkedList<Node>();
    int                   bl, bc;
    Token                 e;
  }
  {
    try
    {
      mf = modifiers()
        [ typeParameters = TypeParameters() ]
        id=<IDENTIFIER>
        params=formalParameters()
        [ "throws" exceptions=ReferenceTypeNameList() ]
        "{"
        [ LOOKAHEAD( explicitConstructorInvocationLookahead() )
           ci=explicitConstructorInvocation() ]
        ( stmt=blockStatement()
           {
        stmts.addAll(stmt);
      }
      )*
        e="}"
      {
        if(mf !=null) //Modifiers not allowed in a constructor declaration
          checkModifiers(mf.accessFlags, Modifier.STATIC | Modifier.FINAL | Modifier.NATIVE | Modifier.ABSTRACT
                           | Modifier.SYNCHRONIZED | Modifier.TRANSIENT | Modifier.VOLATILE);
        if (t == null) {
          bl = id.beginLine;
          bc = id.beginColumn;
        } else {
          bl = t.beginLine;
          bc = t.beginColumn;
        }
        if(lastFormalParameterIsVarArgs) flag |= 0x00000080; // Modifier.VARARGS == 0x00000080 /**/
        if (typeParameters == null){
          return new ConstructorDeclaration(flag, id.image, params, exceptions, ci, stmts,
                                            filename, bl, bc, e.endLine, e.endColumn);
        } else {
          GenericTypesEnv = GenericTypesEnv.getRest(); // pop added type params
          return new PolymorphicConstructorDeclaration(flag, id.image, params,
                                                       exceptions, ci, stmts,
                                                       filename, bl, bc, e.endLine, e.endColumn, typeParameters);
        }
      }
    }
    catch(ParseException pe) {
      _throwParseException(pe, "Invalid constructor declaration");
    }
  }
  
  /**
   * Parses a constructor invocation
   * @see koala.dynamicjava.tree.ConstructorInvocation
   */
  ConstructorInvocation explicitConstructorInvocation() :
  {
    Token           b, e;
    ArgumentsSuffix args;
    Expression      exp = null;
    List<TypeName> typeArgs = new LinkedList<TypeName>();
  }
  {
    try
    {
      ( LOOKAHEAD([TypeArguments()] "this" arguments(typeArgs) ";")
         [ typeArgs = TypeArguments() ]
         b="this" args=arguments(typeArgs) e=";"
         |
       [ LOOKAHEAD(2) exp=primaryExpression() "." ]
         [LOOKAHEAD(TypeArguments()) typeArgs = TypeArguments()]
         b="super" args=arguments(typeArgs) e=";"
         )
      {
        return new ConstructorInvocation(exp, args.arguments, b.image.equals("super"),
                                         filename,
                                         b.beginLine, b.beginColumn,
                                         e.endLine,   e.endColumn);
      }
    }
    catch(ParseException pe) {
      _throwParseException(pe, "Invalid constructor invocation");
    }
  }
  
  // Productions for Interfaces ///////////////////////////////////////////////////
  
  /**
   * Parses a interface declaration
   * @see koala.dynamicjava.tree.InterfaceDeclaration
   */
  InterfaceDeclaration interfaceDeclaration() :
  {
    InterfaceDeclaration id;
    ModifierFlags        md;
  }
  {
    md=modifiers() id=unmodifiedInterfaceDeclaration(md)
    {
      if(md != null) {
        checkModifiers(md.accessFlags, Modifier.FINAL | Modifier.NATIVE | Modifier.SYNCHRONIZED | Modifier.TRANSIENT | Modifier.VOLATILE);
      }
      return id;
    }
  }
  
  /**
   * Parses a interface declaration without modifier
   * @see koala.dynamicjava.tree.InterfaceDeclaration
   */
  InterfaceDeclaration unmodifiedInterfaceDeclaration(ModifierFlags mf) :
  {
    Token t;
    Token id;
    Token e;
    TypeParameter[] typeParameters = null;
    List<? extends ReferenceTypeName> impl = null;
    List<Node> list = new LinkedList<Node>();
    List<Node>  decl;
    int   m = 0;
  }
  {
    try
    {
      t="interface" id=<IDENTIFIER>
        [ typeParameters = TypeParameters() ]
        [ "extends" impl=ReferenceTypeNameList() ]
        "{"
        (
         decl=interfaceMemberDeclaration()
           {
        list.addAll(decl);
      }
      )*
        e="}"
      {
        if (mf != null) {
          m = mf.accessFlags;
        }
        if (typeParameters == null){
          return new InterfaceDeclaration(m, id.image, impl, list,
                                          filename,
                                          t.beginLine, t.beginColumn,
                                          e.endLine,   e.endColumn);
        } else {
          GenericTypesEnv = GenericTypesEnv.getRest(); // pop added type params
          return new GenericInterfaceDeclaration(m, id.image, impl, list,
                                                 filename,
                                                 t.beginLine, t.beginColumn,
                                                 e.endLine, e.endColumn,
                                                 typeParameters);
        }
      }
    }
    catch(ParseException pe) {
      _throwParseException(pe, "Invalid interface declaration");
    }
  }
  
  /**
   * Parses one declaration in the body of an interface.
   * @return a list of node because one field declaration can
   *         contain multiple declarations.
   * @see koala.dynamicjava.tree.Node
   */
  List<Node> interfaceMemberDeclaration() :
  {
    Node node = null;
    List<Node> list = new LinkedList<Node>();
  }
  {
    try
    {
      ( LOOKAHEAD( classDeclarationLookahead() )
         node=classDeclaration()
         |
       LOOKAHEAD( enumDeclarationLookahead() )
         node=enumDeclaration()
         |
       LOOKAHEAD( interfaceDeclarationLookahead() )
         node=interfaceDeclaration()
         |
       LOOKAHEAD( methodDeclarationLookahead() )
         node=methodDeclaration()
         |
       list=fieldDeclaration()
         )
      {
        if (node != null) {
          list.add(node);
        }
        return list;
      }
    }
    catch(ParseException pe) {
      _throwParseException(pe, "Invalid interface member declaration");
    }
  }
  
  // Productions for Enums ////////////////////////////////////////////////////////
  
  /**
   * Parses an enum declaration
   * @see koala.dynamicjava.tree.EnumDeclaration
   */
  EnumDeclaration enumDeclaration() :
  {
    EnumDeclaration  ed;
    ModifierFlags    md;
  }
  {
    md=modifiers() ed = unmodifiedEnumDeclaration(md)
    {
      if(md != null) {
        checkModifiers(md.accessFlags, Modifier.FINAL | Modifier.ABSTRACT | Modifier.NATIVE | Modifier.SYNCHRONIZED | Modifier.TRANSIENT | Modifier.VOLATILE);
      }
      return ed;
    }
  }
  
  EnumDeclaration unmodifiedEnumDeclaration(ModifierFlags mf) :
  {
    Token            t, e;
    Token            id;
    List<? extends ReferenceTypeName> impl = null;
    EnumDeclaration.EnumBody   body;
    int   m = 0;
  }
  {
    t=<ENUM>
      id=<IDENTIFIER>
      ["implements" impl=ReferenceTypeNameList()]
      "{"
      body = enumBody()
      e="}"
    {
      if (mf != null) m = mf.accessFlags;
      return new EnumDeclaration(m, id.image, impl, body,
                                 filename,
                                 t.beginLine, t.beginColumn,
                                 e.endLine,   e.endColumn);
    }
  }
  
  /**
   * Parses the body of an enum
   * @see koala.dynamicjava.tree.Node
   */
  EnumDeclaration.EnumBody enumBody() :
  {
    List<EnumDeclaration.EnumConstant> consts = new LinkedList<EnumDeclaration.EnumConstant>();
    List<Node>         decl = null;
  }
  {
    [ consts = enumConstants() ]
      [","]
      [ decl = enumBodyDeclarations() ]
    {
      return new EnumDeclaration.EnumBody(consts, ((decl==null)? new LinkedList<Node>() : decl));
    }
  }
  
  List<EnumDeclaration.EnumConstant> enumConstants() :
  {
    List<EnumDeclaration.EnumConstant> list = new LinkedList<EnumDeclaration.EnumConstant>();
    EnumDeclaration.EnumConstant individual = null;
  }
  {
    individual = enumConstant()
    { list.add(individual); }
    (LOOKAHEAD(2)
       ","
       individual = enumConstant()
       { list.add(individual); }
    )*
      
    {
      return list;
    }
  }
  
  EnumDeclaration.EnumConstant enumConstant() :
  {
    List<Node>       body = new LinkedList<Node>();
    ArgumentsSuffix args = null;
    Token                id;
    ClassBody            _classBody = null;
  }
  {
    id = <IDENTIFIER>
      [ args = arguments(null) ] // quite unnaturally, type parameters for polymorphic enum constructors (which are allowed) cannot be specified!!
      [ _classBody = classBody() ]
      
    {
      return new EnumDeclaration.EnumConstant(id.image, (args==null) ? null : args.arguments, (_classBody == null)? null : _classBody.list);
    }
  }
  
  List<Node> enumBodyDeclarations() :
  {
    List<Node> body = new LinkedList<Node>();
    List<Node> decl = null;
  }
  {
    ";"
      (
       decl = classBodyDeclaration()
         { body.addAll(decl); }
    )*
      
    {
      return body;
    }
  }
  
  
  // Productions for Arrays ////////////////////////////////////////////////////////
  
  /**
   * Parses an array initializer
   * @see koala.dynamicjava.tree.ArrayInitializer
   */
  ArrayInitializer arrayInitializer() :
  {
    Expression init;
    Token      t = null, b, e;
    List<Expression> list = new LinkedList<Expression>();
  }
  {
    b="{" [ init=variableInitializer()
             {
      list.add(init);
    }
           ( LOOKAHEAD(2)
              "," init=variableInitializer()
              {
             list.add(init);
           }
           )* ]
             [ t="," ] e="}"
           {
             return new ArrayInitializer(list,
                                         filename,
                                         b.beginLine, b.beginColumn,
                                         e.endLine,   e.endColumn);
           }
  }
  
  /**
   * Parses a variable initializer (ie. an expression or an array initializer)
   * @see koala.dynamicjava.tree.Expression
   */
  Expression variableInitializer() :
  {
    Expression exp;
  }
  {
    ( exp=arrayInitializer()
       | exp=expression() )
    {
      return exp;
    }
  }
  
  // Productions for Blocks And Statements ////////////////////////////////////////////
  
  /**
   * Parses a block
   * @see koala.dynamicjava.tree.BlockStatement
   */
  BlockStatement block() :
  {
    Token p1;
    Token p2;
    List<Node> nodes;
    List<Node> list = new LinkedList<Node>();
  }
  {
    try {
      p1="{"
        ( nodes=blockStatement()
           {
        list.addAll(nodes);
      }
      )*
        p2="}"
      {
        return new BlockStatement(list,
                                  filename,
                                  p1.beginLine, p1.beginColumn,
                                  p2.endLine,   p2.endColumn);
      }
    }
    catch(ParseException pe) {
      _throwParseException(pe,"Invalid block statement");
    }
  }
  
  /**
   * Parses one block statement.
   * @return a list of node because one variable declaration can
   *         contain multiple declarations.
   * @see koala.dynamicjava.tree.Node
   */
  List<Node> blockStatement() :
  {
    Node node = null;
    List<Node> list = new LinkedList<Node>();
  }
  {
    try {
      (    LOOKAHEAD([ "final" ] typeLookahead() <IDENTIFIER>)
         list=localVariableDeclaration() ";"
         | node=statement()
         {
        list.add(node);
      }
       | node=unmodifiedClassDeclaration(null)
         {
         list.add(node);
       }
       | node=unmodifiedEnumDeclaration(null)
         {
         list.add(node);
       }
       | node=unmodifiedInterfaceDeclaration(null)
         {
         list.add(node);
       }
       )
       {
         return list;
       }
    }
    catch(ParseException pe) {
      _throwParseException(pe,"Invalid block statement");
    }
  }
  
  /**
   * Parses one variable declaration
   * @return a list of node because one variable declaration can
   *         contain multiple declarations.
   * @see koala.dynamicjava.tree.VariableDeclaration
   */
  List<Node> localVariableDeclaration() :
  {
    Token      t    = null;
    Expression init = null;
    TypeName       typ;
    Token      id;
    int        dim  = 0;
    List<Node>       list = new LinkedList<Node>();
  }
  {
    [ t="final" ]
      typ=type() id=<IDENTIFIER> ( "[" "]" { dim++; } )*
        [ "=" init=variableInitializer() ]
      {
        list.add(createVariableDeclaration(t, typ, id, init, dim));
      }
      ( { init = null; dim = 0; }
       ","  id=<IDENTIFIER> ( "[" "]" { dim++; } )*
       [ "=" init=variableInitializer() ]
         {
         list.add(createVariableDeclaration(t, typ, id, init, dim));
       }
       )*
       {
         return list;
       }
  }
  
  /**
   * Parses one statement
   * @see koala.dynamicjava.tree.Node
   */
  Node statement() :
  {
    Node node = null;
  }
  {
    ( LOOKAHEAD(2)
       node=labeledStatement()
       | node=block()
       | node=emptyStatement()
       | node=statementExpression() ";"
       | node=ifStatement()
       | node=assertStatement()
       | node=whileStatement()
       | node=doStatement()
       | node=switchStatement()
       | node=forStatement()
       | node=breakStatement()
       | node=continueStatement()
       | node=returnStatement()
       | node=throwStatement()
       | node=synchronizedStatement()
       | node=tryStatement()
       )
    {
      return node;
    }
  }
  
  /**
   * Parses a labeled statement
   * @see koala.dynamicjava.tree.ContinueTarget
   * @see koala.dynamicjava.tree.LabeledStatement
   */
  Statement labeledStatement() :
  {
    Token id;
    Node  node;
  }
  {
    id=<IDENTIFIER> ":" node=statement()
    {
      if (node instanceof ContinueTarget) {
        ((ContinueTarget)node).addLabel(id.image);
        return (Statement)node;
      } else {
        return new LabeledStatement(id.image, node,
                                    filename,
                                    id.beginLine,      id.beginColumn,
                                    node.getEndLine(), node.getEndColumn());
      }
    }
  }
  
  /**
   * Parses an empty statement
   * @see koala.dynamicjava.tree.EmptyStatement
   */
  EmptyStatement emptyStatement() :
  {
    Token t;
  }
  {
    t=";"
    {
      return new EmptyStatement(filename, t.beginLine, t.beginColumn);
    }
  }
  
  /**
   * Parses an if statement
   * @see koala.dynamicjava.tree.IfThenStatement
   * @see koala.dynamicjava.tree.IfThenElseStatement
   */
  Statement ifStatement() :
  {
    Token t;
    Expression exp;
    Node       stat1;
    Node       stat2 = null;
  }
  {
    try {
      t="if" ( "(" | _errorChar('('))
        exp=expression() ")"
        stat1=statement()
        [ LOOKAHEAD(1) "else" stat2=statement() ]
      {
        if (stat2 == null) {
          return new IfThenStatement(exp, stat1,
                                     filename,
                                     t.beginLine,       t.beginColumn,
                                     stat1.getEndLine(), stat1.getEndColumn());
        } else {
          return new IfThenElseStatement(exp, stat1, stat2,
                                         filename,
                                         t.beginLine,       t.beginColumn,
                                         stat2.getEndLine(), stat2.getEndColumn());
        }
      }
    }
    catch(ParseException pe) {
      _throwParseException(pe,"Invalid if statement");
    }
  }
  
  
  /**
   * Parses an assert statement
   * @see koala.dynamicjava.tree.AssertStatement
   */
  AssertStatement assertStatement() :
  {
    Token t, t2;
    Expression exp, falseString = null;
  }
  {
    try { 
      t="assert" exp=expression() [":" falseString=expression()] (t2=";" | t2=<EOF>)
      {   
        return new AssertStatement(exp, falseString, filename,
                                   t.beginLine,      t.beginColumn,
                                   t2.endLine, t2.endColumn);
      }
    }
    catch(ParseException pe) {
      _throwParseException(pe,"Invalid assert statement");
    }
  }
  
  
  /**
   * Parses a while statement
   * @see koala.dynamicjava.tree.WhileStatement
   */
  WhileStatement whileStatement() :
  {
    Token      t;
    Expression exp;
    Node       stat;
  }
  {
    
    try{
      t="while" ( "(" | _errorChar('('))
        exp=expression() ")"
        stat=statement()
      {
        return new WhileStatement(exp, stat,
                                  filename,
                                  t.beginLine,       t.beginColumn,
                                  stat.getEndLine(), stat.getEndColumn());
      }
    }
    catch(ParseException pe) {
      _throwParseException(pe,"Invalid while statement");
    }
  }
  
  /**
   * Parses a do statement
   * @see koala.dynamicjava.tree.DoStatement
   */
  DoStatement doStatement() :
  {
    Token      t1, t2;
    Expression exp;
    Node       stat;
  }
  {
    try {
      t1="do" stat=statement() "while"
        ( "(" | _errorChar('('))
        exp=expression() ")" t2=";"
      {
        return new DoStatement(exp, stat,
                               filename,
                               t1.beginLine, t1.beginColumn,
                               t2.endLine,   t2.endColumn);
      }
    }
    catch(ParseException pe) {
      _throwParseException(pe,"Invalid do statement");
    }
  }
  
  /**
   * Parses a switch statement
   * @see koala.dynamicjava.tree.SwitchStatement
   */
  SwitchStatement switchStatement() :
  {
    Token      b, e;
    Expression sel;
    Expression val         = null;
    List<Node>        stat        = null;
    List<SwitchBlock> cases       = new LinkedList<SwitchBlock>();
    List<Node>       list        = new LinkedList<Node>();
    Token      t           = null;
  }
  {
    try {
      b="switch" ( "(" | _errorChar('('))
        sel=expression() ")"
        ( "{" | _errorChar('{'))
        ( ( "case" val=expression() | t="default" )
           (":" | _errorChar(':'))
           ( stat=blockStatement()
              {
        list.addAll(stat);
      }
      )*
         {
        int bl, bc, el, ec;
        if (t != null) {
          bl = t.beginLine;
          bc = t.beginColumn;
          el = t.endLine;
          ec = t.endColumn;
        } else {
          bl = val.getBeginLine();
          bc = val.getBeginColumn();
          el = val.getEndLine();
          ec = val.getEndColumn();
        }
        
        if (list.size() != 0) {
          Node n = (Node)list.get(list.size() - 1);
          el = n.getEndLine();
          ec = n.getEndColumn();
        }
        
        cases.add(new SwitchBlock(val, (list.size() != 0) ? list : null,
                                  filename,
                                  bl, bc, el, ec));
        val = null;
        t   = null;
        if (list.size() != 0) {
          list = new LinkedList<Node>();
        }
      }
      )*
        e="}"
      {
        return new SwitchStatement(sel, cases,
                                   filename,
                                   b.beginLine, b.beginColumn,
                                   e.endLine,   e.endColumn);
      }
    }
    catch(ParseException pe) {
      _throwParseException(pe,"Invalid switch statement");
    }
  }
  
  /**
   * Parses a for statement (with standard or foreach syntax)
   * @see koala.dynamicjava.tree.ForStatement
   * Modified by Adam Wulf and David Peters
   * March 2004: Dr. Java team.
   * @see koala.dynamicjava.tree.ForSlashEachStatement
   * @see koala.dynamicjava.tree.ForEachStatement
   */
  ForSlashEachStatement forStatement() :
  {
    Token      t;
    FormalParameter forEachInit = null;
    List<Node>       init   = null;
    Expression exp    = null;
    List<Node>       update = null;
    Node       stmt;
    Token      colon  = null;
  }
  {
    try {
      t="for" ( "(" | _errorChar('('))
        (
         LOOKAHEAD(formalParameterLookahead() ":")
           forEachInit=formalParameter() colon=":" exp=expression()
           |
         [ init=forInit()] ";"
           [ exp=expression() ] ";"
           [ update=statementExpressionList() ]
           )
        ")" stmt=statement()
      {
        if(colon != null){
          return new ForEachStatement(forEachInit, exp, stmt,
                                      filename,
                                      t.beginLine, t.beginColumn,
                                      stmt.getEndLine(), stmt.getEndColumn());
        }else{
          return new ForStatement(init, exp, update, stmt,
                                  filename,
                                  t.beginLine, t.beginColumn,
                                  stmt.getEndLine(), stmt.getEndColumn());
          
        }
      }
    }
    catch(ParseException pe) {
      _throwParseException(pe,"Invalid for statement");
    }
  }
  
  /**
   * Used internally to parse a 'for' statement
   */
  List<Node> forInit() :
  {
    List<Node> list;
  }
  {
    ( LOOKAHEAD( [ "final" ] typeLookahead() <IDENTIFIER> )
       list=localVariableDeclaration()
       |
     list=statementExpressionList()
       )
    {
      return list;
    }
  }
  
  /**
   * Parses a comma separated list of expression
   */
  List<Node> statementExpressionList() :
  {
    List<Node> list = new LinkedList<Node>();
    Node node;
  }
  {
    node=statementExpression()
    {
      list.add(node);
    }
    ( "," node=statementExpression()
       {
      list.add(node);
    }
    )*
    {
      return list;
    }
  }
  
  /**
   * Parses a break statement
   * @see koala.dynamicjava.tree.BreakStatement
   */
  BreakStatement breakStatement() :
  {
    Token b, e;
    Token id = null;
  }
  {
    try {
      b="break" [ id=<IDENTIFIER> ] e=";"
      {
        return new BreakStatement((id != null) ? id.image : null,
                                  filename,
                                  b.beginLine, b.beginColumn,
                                  e.endLine,   e.endColumn);
      }
    }
    catch(ParseException pe) {
      _throwParseException(pe,"Invalid break statement");
    }
  }
  
  /**
   * Parses a continue statement
   * @see koala.dynamicjava.tree.ContinueStatement
   */
  ContinueStatement continueStatement() :
  {
    Token b, e;
    Token id = null;
  }
  {
    try {
      b="continue" [ id=<IDENTIFIER> ] e=";"
      {
        return new ContinueStatement((id != null) ? id.image : null,
                                     filename,
                                     b.beginLine, b.beginColumn,
                                     e.endLine,   e.endColumn);
      }
    }
    catch(ParseException pe) {
      _throwParseException(pe,"Invalid continue statement");
    }
  }
  
  /**
   * Parses a return statement
   * @see koala.dynamicjava.tree.ReturnStatement
   */
  ReturnStatement returnStatement() :
  {
    Token b, e;
    Expression exp = null;
  }
  {
    try {
      b="return" [ exp=expression() ] e=";"
      {
        return new ReturnStatement(exp,
                                   filename,
                                   b.beginLine, b.beginColumn,
                                   e.endLine,   e.endColumn);
      }
    }
    catch(ParseException pe) {
      _throwParseException(pe,"Invalid return statement");
    }
  }
  
  /**
   * Parses a throw statement
   * @see koala.dynamicjava.tree.ThrowStatement
   */
  ThrowStatement throwStatement() :
  {
    Token b, e;
    Expression exp;
  }
  {
    try {
      b="throw" exp=expression() e=";"
      {
        return new ThrowStatement(exp,
                                  filename,
                                  b.beginLine, b.beginColumn,
                                  e.endLine,   e.endColumn);
      }
    }
    catch(ParseException pe) {
      _throwParseException(pe,"Invalid throw statement");
    }
  }
  
  /**
   * Parses a synchronized statement
   * @see koala.dynamicjava.tree.SynchronizedStatement
   */
  SynchronizedStatement synchronizedStatement() :
  {
    Token      t;
    Expression exp;
    Node       stmt;
  }
  {
    try {
      t="synchronized" ( "(" | _errorChar('('))
        exp=expression() ")" stmt=block()
      {
        return new SynchronizedStatement(exp, stmt,
                                         filename,
                                         t.beginLine, t.beginColumn,
                                         stmt.getEndLine(), stmt.getEndColumn());
      }
    }
    catch(ParseException pe) {
      _throwParseException(pe,"Invalid synchronized statement");
    }
  }
  
  /**
   * Parses a try statement
   * @see koala.dynamicjava.tree.TryStatement
   */
  TryStatement tryStatement() :
  {
    Token           t, u;
    Node            tryBlock;
    Node            catchBlock;
    List<CatchStatement>      catches = new LinkedList<CatchStatement>();
    FormalParameter formal;
    Node            finallyBlock = null;
    int             el = 0, ec = 0;
  }
  {
    try{
      t="try" tryBlock=block()
        ( u="catch" ( "(" | _errorChar('('))
           formal=formalParameter() ")" catchBlock=block()
           {
        el = catchBlock.getEndLine();
        ec = catchBlock.getEndColumn();
        catches.add(new CatchStatement(formal, catchBlock,
                                       filename,
                                       u.beginLine, u.beginColumn,
                                       el, ec));
      }
      )*
        [ "finally" finallyBlock=block()
           {
        el = finallyBlock.getEndLine();
        ec = finallyBlock.getEndColumn();
      }
         ]
         {
           if (finallyBlock == null && catches.size() == 0) {
             throw new ParseError(reader.getMessage("try.without.catch", null),
                                  filename,
                                  t.beginLine, t.beginColumn);
           }
           return new TryStatement(tryBlock, catches, finallyBlock,
                                   filename,
                                   t.beginLine, t.beginColumn,
                                   el, ec);
         }
    }
    catch(ParseException pe) {
      _throwParseException(pe,"Invalid try statement");
    }
  }
  
  /**
   * Parses one statement expression
   * @see koala.dynamicjava.tree.Expression
   */
  Node statementExpression() :
  {
    Expression exp;
    Expression exp2;
    Expression exp3 = null;
    Token      t;
  }
  {
    ( exp=preIncrementExpression()
       | exp=preDecrementExpression()
       | exp=primaryExpression()
       [ t="++"
          {
      exp = new PostIncrement(exp,
                              filename,
                              exp.getBeginLine(), exp.getBeginColumn(),
                              t.endLine,          t.endColumn);
    }
        | t="--"
          {
          exp = new PostDecrement(exp,
                                  filename,
                                  exp.getBeginLine(), exp.getBeginColumn(),
                                  t.endLine,          t.endColumn);
        }
        | exp=expressionSuffix(exp)
          ]
       )
        {
          if (exp instanceof ExpressionStatement) {
            return exp;
          } else {
            throw new ParseError(reader.getMessage("expression.statement", null),
                                 filename,
                                 exp.getBeginLine(), exp.getBeginColumn());
          }
        }
  }
  
  // Productions for Statements /////////////////////////////////////////////////////////
  
  /**
   * Parses an expression
   * @see koala.dynamicjava.tree.Expression
   */
  Expression expression() :
  {
    Expression exp;
  }
  {
    exp=conditionalExpression() [ exp=expressionSuffix(exp) ]
    {
      return exp;
    }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression expressionSuffix(Expression pre) :
  {
    Expression exp2;
    Expression exp;
  }
  {
    ( "="    exp2=expression()
       {
      exp = new SimpleAssignExpression(pre, exp2,
                                       filename,
                                       pre.getBeginLine(), pre.getBeginColumn(),
                                       exp2.getEndLine(),  exp2.getEndColumn());
    }
     | "*="   exp2=expression()
       {
       exp = new MultiplyAssignExpression(pre, exp2,
                                          filename,
                                          pre.getBeginLine(), pre.getBeginColumn(),
                                          exp2.getEndLine(),  exp2.getEndColumn());
     }
     | "/="   exp2=expression()
       {
       exp = new DivideAssignExpression(pre, exp2,
                                        filename,
                                        pre.getBeginLine(), pre.getBeginColumn(),
                                        exp2.getEndLine(),  exp2.getEndColumn());
     }
     | "%="   exp2=expression()
       {
       exp = new RemainderAssignExpression(pre, exp2,
                                           filename,
                                           pre.getBeginLine(), pre.getBeginColumn(),
                                           exp2.getEndLine(),  exp2.getEndColumn());
     }
     | "+="   exp2=expression()
       {
       exp = new AddAssignExpression(pre, exp2,
                                     filename,
                                     pre.getBeginLine(), pre.getBeginColumn(),
                                     exp2.getEndLine(),  exp2.getEndColumn());
     }
     | "-="   exp2=expression()
       {
       exp = new SubtractAssignExpression(pre, exp2,
                                          filename,
                                          pre.getBeginLine(), pre.getBeginColumn(),
                                          exp2.getEndLine(),  exp2.getEndColumn());
     }
     | "<<="  exp2=expression()
       {
       exp = new ShiftLeftAssignExpression(pre, exp2,
                                           filename,
                                           pre.getBeginLine(), pre.getBeginColumn(),
                                           exp2.getEndLine(),  exp2.getEndColumn());
     }
     | ">>="  exp2=expression()
       {
       exp = new ShiftRightAssignExpression
         (pre, exp2,
          filename,
          pre.getBeginLine(), pre.getBeginColumn(),
          exp2.getEndLine(),  exp2.getEndColumn());
     }
     | ">>>=" exp2=expression()
       {
       exp = new UnsignedShiftRightAssignExpression
         (pre, exp2,
          filename,
          pre.getBeginLine(), pre.getBeginColumn(),
          exp2.getEndLine(),  exp2.getEndColumn());
     }
     | "&="   exp2=expression()
       {
       exp = new BitAndAssignExpression(pre, exp2,
                                        filename,
                                        pre.getBeginLine(), pre.getBeginColumn(),
                                        exp2.getEndLine(),  exp2.getEndColumn());
     }
     | "^="   exp2=expression()
       {
       exp = new ExclusiveOrAssignExpression(pre, exp2,
                                             filename,
                                             pre.getBeginLine(), pre.getBeginColumn(),
                                             exp2.getEndLine(),  exp2.getEndColumn());
     }
     | "|="   exp2=expression()
       {
       exp = new BitOrAssignExpression(pre, exp2,
                                       filename,
                                       pre.getBeginLine(), pre.getBeginColumn(),
                                       exp2.getEndLine(),  exp2.getEndColumn());
     }
     )
     {
       if (!(pre instanceof LeftHandSide)) {
         throw new ParseError(reader.getMessage("left.expression.in.assignment",
                                                null),
                              filename,
                              pre.getBeginLine(), pre.getBeginColumn());
       }
       return exp;
     }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression conditionalExpression() :
  {
    Expression exp;
    Expression exp2;
    Expression exp3;
  }
  {
    exp=conditionalOrExpression()
      [ "?" exp2=expression() ":" exp3=conditionalExpression()
         {
      exp = new ConditionalExpression(exp, exp2, exp3,
                                      filename,
                                      exp.getBeginLine(), exp.getBeginColumn(),
                                      exp3.getEndLine(),  exp3.getEndColumn());
    }
       ]
       {
         return exp;
       }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression conditionalOrExpression() :
  {
    Expression exp;
    Expression exp2;
  }
  {
    exp=conditionalAndExpression()
      ( "||" exp2=conditionalAndExpression()
         {
      exp = new OrExpression(exp, exp2,
                             filename,
                             exp.getBeginLine(), exp.getBeginColumn(),
                             exp2.getEndLine(),  exp2.getEndColumn());
    }
    )*
    {
      return exp;
    }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression conditionalAndExpression() :
  {
    Expression exp;
    Expression exp2;
  }
  {
    exp=inclusiveOrExpression()
      ( "&&" exp2=inclusiveOrExpression()
         {
      exp = new AndExpression(exp, exp2,
                              filename,
                              exp.getBeginLine(), exp.getBeginColumn(),
                              exp2.getEndLine(),  exp2.getEndColumn());
    }
    )*
    {
      return exp;
    }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression inclusiveOrExpression() :
  {
    Expression exp;
    Expression exp2;
  }
  {
    exp=exclusiveOrExpression()
      ( "|" exp2=exclusiveOrExpression()
         {
      exp = new BitOrExpression(exp, exp2,
                                filename,
                                exp.getBeginLine(), exp.getBeginColumn(),
                                exp2.getEndLine(),  exp2.getEndColumn());
    }
    )*
    {
      return exp;
    }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression exclusiveOrExpression() :
  {
    Expression exp;
    Expression exp2;
  }
  {
    exp=andExpression()
      ( "^" exp2=andExpression()
         {
      exp = new ExclusiveOrExpression(exp, exp2,
                                      filename,
                                      exp.getBeginLine(), exp.getBeginColumn(),
                                      exp2.getEndLine(),  exp2.getEndColumn());
    }
    )*
    {
      return exp;
    }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression andExpression() :
  {
    Expression exp;
    Expression exp2;
  }
  {
    exp=equalityExpression()
      ( "&" exp2=equalityExpression()
         {
      exp = new BitAndExpression(exp, exp2,
                                 filename,
                                 exp.getBeginLine(), exp.getBeginColumn(),
                                 exp2.getEndLine(),  exp2.getEndColumn());
    }
    )*
    {
      return exp;
    }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression equalityExpression() :
  {
    Expression exp;
    Expression exp2;
  }
  {
    exp=instanceOfExpression()
      ( "==" exp2=instanceOfExpression()
         {
      exp = new EqualExpression(exp, exp2,
                                filename,
                                exp.getBeginLine(), exp.getBeginColumn(),
                                exp2.getEndLine(),  exp2.getEndColumn());
    }
       | "!=" exp2=instanceOfExpression()
         {
         exp = new NotEqualExpression(exp, exp2,
                                      filename,
                                      exp.getBeginLine(), exp.getBeginColumn(),
                                      exp2.getEndLine(),  exp2.getEndColumn());
       }
       )*
       {
         return exp;
       }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression instanceOfExpression() :
  {
    Expression exp;
    TypeName       typ = null;
  }
  {
    exp=relationalExpression() [ "instanceof" typ=type() ]
    {
      if (typ != null) {
        return new InstanceOfExpression(exp, typ,
                                        filename,
                                        exp.getBeginLine(), exp.getBeginColumn(),
                                        typ.getEndLine(),   typ.getEndColumn());
      } else {
        return exp;
      }
    }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression relationalExpression() :
  {
    Expression exp;
    Expression exp2;
  }
  {
    exp=shiftExpression()
      ( "<"  exp2=shiftExpression()
         {
      exp = new LessExpression(exp, exp2,
                               filename,
                               exp.getBeginLine(), exp.getBeginColumn(),
                               exp2.getEndLine(),  exp2.getEndColumn());
    }
       | ">"  exp2=shiftExpression()
         {
         exp = new GreaterExpression(exp, exp2,
                                     filename,
                                     exp.getBeginLine(), exp.getBeginColumn(),
                                     exp2.getEndLine(),  exp2.getEndColumn());
       }
       | "<=" exp2=shiftExpression()
         {
         exp = new LessOrEqualExpression(exp, exp2,
                                         filename,
                                         exp.getBeginLine(), exp.getBeginColumn(),
                                         exp2.getEndLine(),  exp2.getEndColumn());
       }
       | ">=" exp2=shiftExpression()
         {
         exp = new GreaterOrEqualExpression(exp, exp2,
                                            filename,
                                            exp.getBeginLine(), exp.getBeginColumn(),
                                            exp2.getEndLine(),  exp2.getEndColumn());
       }
       )*
       {
         return exp;
       }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression shiftExpression() :
  {
    Expression exp;
    Expression exp2;
  }
  {
    exp=additiveExpression()
      ( "<<"  exp2=additiveExpression()
         {
      exp = new ShiftLeftExpression(exp, exp2,
                                    filename,
                                    exp.getBeginLine(), exp.getBeginColumn(),
                                    exp2.getEndLine(),  exp2.getEndColumn());
    }
       | <RSSHIFT1> <RSSHIFT2>  exp2=additiveExpression()
         {
         exp = new ShiftRightExpression(exp, exp2,
                                        filename,
                                        exp.getBeginLine(), exp.getBeginColumn(),
                                        exp2.getEndLine(),  exp2.getEndColumn());
       }
       | <RUSHIFT1> <RUSHIFT2> <RUSHIFT3> exp2=additiveExpression()
         {
         exp = new UnsignedShiftRightExpression
           (exp, exp2,
            filename,
            exp.getBeginLine(), exp.getBeginColumn(),
            exp2.getEndLine(),  exp2.getEndColumn());
       }
       )*
       {
         return exp;
       }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression additiveExpression() :
  {
    Expression exp;
    Expression exp2;
  }
  {
    exp=multiplicativeExpression()
      ( "+" exp2=multiplicativeExpression()
         {
      exp = new AddExpression(exp, exp2,
                              filename,
                              exp.getBeginLine(), exp.getBeginColumn(),
                              exp2.getEndLine(),  exp2.getEndColumn());
    }
       | "-" exp2=multiplicativeExpression()
         {
         exp = new SubtractExpression(exp, exp2,
                                      filename,
                                      exp.getBeginLine(), exp.getBeginColumn(),
                                      exp2.getEndLine(),  exp2.getEndColumn());
       }
       )*
       {
         return exp;
       }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression multiplicativeExpression() :
  {
    Expression exp;
    Expression exp2;
  }
  {
    exp=unaryExpression()
      ( "*" exp2=unaryExpression()
         {
      exp = new MultiplyExpression(exp, exp2,
                                   filename,
                                   exp.getBeginLine(), exp.getBeginColumn(),
                                   exp2.getEndLine(),  exp2.getEndColumn());
    }
       | "/" exp2=unaryExpression()
         {
         exp = new DivideExpression(exp, exp2,
                                    filename,
                                    exp.getBeginLine(), exp.getBeginColumn(),
                                    exp2.getEndLine(),  exp2.getEndColumn());
       }
       | "%" exp2=unaryExpression()
         {
         exp = new RemainderExpression(exp, exp2,
                                       filename,
                                       exp.getBeginLine(), exp.getBeginColumn(),
                                       exp2.getEndLine(),  exp2.getEndColumn());
       }
       )*
       {
         return exp;
       }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression unaryExpression() :
  {
    Expression exp = null;
    Token      t,tk;
  }
  {
    ( t="+" exp=unaryExpression()
       {
      return new PlusExpression(exp,
                                filename,
                                t.beginLine,      t.beginColumn,
                                exp.getEndLine(), exp.getEndColumn());
    }
     |
     t="-" (LOOKAHEAD(1)tk=<INTEGER_LITERAL>{return new IntegerLiteral("-"+tk.image,
                                  filename,
                                  t.beginLine, t.beginColumn,
                                                           tk.endLine,   tk.endColumn);
                                 }
            |LOOKAHEAD(1)tk=<LONG_LITERAL>{
              if(tk.image.endsWith("L")) tk.image=tk.image.substring(0,tk.image.length()-1);
              return new LongLiteral("-"+tk.image, filename, t.beginLine, t.beginColumn,
                                                   tk.endLine,   tk.endColumn);
             }
           | exp=unaryExpression(){
               return new MinusExpression(exp, filename,
                                          t.beginLine,      t.beginColumn,
                                          exp.getEndLine(), exp.getEndColumn());
             }
           )
     |
     exp=preIncrementExpression()
       |
     exp=preDecrementExpression()
       |
     exp=unaryExpressionNotPlusMinus() )
     {
       return exp;
     }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression unaryExpressionNotPlusMinus() :
  {
    Expression exp;
    Token      t;
  }
  {
    ( t="~" exp=unaryExpression()
       {
      return new ComplementExpression(exp,
                                      filename,
                                      t.beginLine,      t.beginColumn,
                                      exp.getEndLine(), exp.getEndColumn());
    }
     |
     t="!" exp=unaryExpression()
       {
       return new NotExpression(exp,
                                filename,
                                t.beginLine,      t.beginColumn,
                                exp.getEndLine(), exp.getEndColumn());
     }
     |
     LOOKAHEAD( castLookahead() )
       exp=castExpression()
       |
     exp=postfixExpression() )
     {
       return exp;
     }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression castExpression() :
  {
    TypeName       typ;
    Token      t;
    Expression exp;
  }
  {
    ( LOOKAHEAD("(" primitiveTypeLookahead())
       t="(" typ=type() ")" exp=unaryExpression()
       |
     t="(" typ=type() ")" exp=unaryExpressionNotPlusMinus() )
    {
      return new CastExpression(typ, exp,
                                filename,
                                t.beginLine, t.beginColumn,
                                exp.getEndLine(), exp.getEndColumn());
    }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression preIncrementExpression() :
  {
    Expression pe;
    Token      t;
  }
  {
    t="++" pe=primaryExpression()
    {
      return new PreIncrement(pe,
                              filename,
                              pe.getBeginLine(), pe.getBeginColumn(),
                              t.endLine,         t.endColumn);
    }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression preDecrementExpression() :
  {
    Expression pe;
    Token      t;
  }
  {
    t="--" pe=primaryExpression()
    {
      return new PreDecrement(pe,
                              filename,
                              pe.getBeginLine(), pe.getBeginColumn(),
                              t.endLine,         t.endColumn);
    }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression postfixExpression() :
  {
    Expression pe;
    Token      t;
  }
  {
    pe=primaryExpression()
      [ t="++"
         {
      return new PostIncrement(pe,
                               filename,
                               pe.getBeginLine(), pe.getBeginColumn(),
                               t.endLine,         t.endColumn);
    }
       | t="--"
         {
         return new PostDecrement(pe,
                                  filename,
                                  pe.getBeginLine(), pe.getBeginColumn(),
                                  t.endLine,         t.endColumn);
       }
       ]
       {
         return pe;
       }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression primaryExpression() :
  {
    Expression       pp;
    ExpressionSuffix es;
    List<ExpressionSuffix> list = new LinkedList<ExpressionSuffix>();
    List<TypeName> typeArgs = new LinkedList<TypeName>();
  }
  {
    [LOOKAHEAD(TypeArguments()) typeArgs = TypeArguments()]
      pp=primaryPrefix()
      ( LOOKAHEAD(2) es=primarySuffix(typeArgs)
         {
      // Build the list of suffixes in reverse order
      list.add(0, es);
    }
    )*
    {
      return createPrimaryExpression(pp, list);
    }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression primaryPrefix() :
  {
    Expression exp;
  }
  {
    ( exp=literal()
       | exp=thisExpression()
       | exp=superExpression()
       | exp=allocationExpression()
       | "(" exp=expression() ")"
       | LOOKAHEAD( resultTypeLookahead() "." "class" ) exp=classExpression()
       | exp=qualifiedName()
       )
    {
      return exp;
    }
  }
  
  /**
   * Used internally to parse an expression
   */
  ExpressionSuffix primarySuffix(List<TypeName> typeArgs) :
  {
    ExpressionSuffix es;
  }
  {
    ( LOOKAHEAD(2) es=dotThis()
       | LOOKAHEAD(2) es=dotAllocationExpression()
       | es=arrayReference()
       | es=dotIdentifier()
       | es=arguments(typeArgs)
       )
    {
      return es;
    }
  }
  
  /**
   * Used internally to parse an expression
   */
  ExpressionSuffix dotThis() :
  {
    Token t;
  }
  {
    "." t="this"
    {
      return new DotThisSuffix(t.endLine, t.endColumn);
    }
  }
  
  /**
   * Used internally to parse an expression
   */
  ExpressionSuffix dotAllocationExpression() :
  {
    Allocation a;
  }
  {
    "." a=simpleAllocationExpression()
    {
      return new DotAllocationSuffix(a);
    }
  }
  
  /**
   * Used internally to parse an expression
   */
  Allocation simpleAllocationExpression() :
  {
    Token           t;
    ReferenceTypeName   rt;
    ArgumentsSuffix as;
    ClassBody       cb = null;
    List<TypeName> typeArgs = new LinkedList<TypeName>();
  }
  {
    
    t="new"
      [LOOKAHEAD(TypeArguments()) typeArgs = TypeArguments()]
      rt=ReferenceTypeName() as=arguments(typeArgs) [ cb=classBody() ]
    {
      if (cb == null) {
        if(typeArgs.size() > 0)
          return new PolymorphicSimpleAllocation(rt,
                                                 as.arguments,
                                                 typeArgs,
                                                 filename,
                                                 t.beginLine, t.beginColumn,
                                                 as.endLine, as.endColumn);
        return new SimpleAllocation(rt,
                                    as.arguments,
                                    filename,
                                    t.beginLine, t.beginColumn,
                                    as.endLine,  as.endColumn);
      } else {
        if(typeArgs.size() > 0)
          return new PolymorphicClassAllocation(rt,
                                                as.arguments,
                                                cb.list,
                                                typeArgs,
                                                filename,
                                                t.beginLine, t.beginColumn,
                                                as.endLine, as.endColumn);
        return new ClassAllocation(rt,
                                   as.arguments,
                                   cb.list,
                                   filename,
                                   t.beginLine, t.beginColumn,
                                   cb.endLine,  cb.endColumn);
      }
    }
  }
  
  /**
   * Used internally to parse an expression
   */
  ExpressionSuffix dotIdentifier() :
  {
    Token id;
  }
  {
    "." id=<IDENTIFIER>
    {
      return new DotIdentifierSuffix(id);
    }
  }
  
  /**
   * Used internally to parse an expression
   */
  ExpressionSuffix arrayReference() :
  {
    Expression exp;
    Token      t;
  }
  {
    "[" exp=expression() t="]"
    {
      return new ArrayReferenceSuffix(exp, t.endLine, t.endColumn);
    }
  }
  
  /**
   * Used internally to parse an expression
   */
  ArgumentsSuffix arguments(List<TypeName> typeArgs) :
  {
    List<Expression> list = null;
    Token t;
  }
  {
    "(" [ list=argumentList() ] t=")"
    {
      return new ArgumentsSuffix(list, typeArgs, t.endLine, t.endColumn);
    }
  }
  
  /**
   * Used internally to parse an expression
   */
  List<Expression> argumentList() :
  {
    List<Expression> list = new LinkedList<Expression>();
    Expression exp;
  }
  {
    exp=expression()
    {
      list.add(exp);
    }
    ( "," exp=expression()
       {
      list.add(exp);
    }
    )*
    {
      return list;
    }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression literal() :
  {
    Token t;
  }
  {
    try {
      t=<INTEGER_LITERAL>
      {
        // if(t.image.equals("2147483648")){t.image = "-2147483648";} // Introduced an error with int x = 2147483648
        
        
        return new IntegerLiteral(t.image,
                                  filename,
                                  t.beginLine, t.beginColumn,
                                  t.endLine,   t.endColumn);
      }
      |
        t=<LONG_LITERAL>
      {
        if(t.image.endsWith("L")) t.image=t.image.substring(0,t.image.length()-1);
           return new LongLiteral(t.image, filename,
                                  t.beginLine, t.beginColumn,
                                  t.endLine,   t.endColumn);
      }
      |
        t=<FLOAT_LITERAL>
      {
        return new FloatLiteral(t.image,
                                filename,
                                t.beginLine, t.beginColumn,
                                t.endLine,   t.endColumn);
      }
      |
        t=<DOUBLE_LITERAL>
      {
        return new DoubleLiteral(t.image,
                                 filename,
                                 t.beginLine, t.beginColumn,
                                 t.endLine,   t.endColumn);
      }
      |
        t=<CHARACTER_LITERAL>
      {
        return new CharacterLiteral(t.image,
                                    filename,
                                    t.beginLine, t.beginColumn,
                                    t.endLine,   t.endColumn);
      }
      |
        t=<STRING_LITERAL>
      {
        return new StringLiteral(t.image,
                                 filename,
                                 t.beginLine, t.beginColumn,
                                 t.endLine,   t.endColumn);
      }
      |
        t="true"
      {
        return new BooleanLiteral(true,
                                  filename,
                                  t.beginLine, t.beginColumn,
                                  t.endLine,   t.endColumn);
      }
      |
        t="false"
      {
        return new BooleanLiteral(false,
                                  filename,
                                  t.beginLine, t.beginColumn,
                                  t.endLine,   t.endColumn);
      }
      |
        t="null"
      {
        return new NullLiteral(filename,
                               t.beginLine, t.beginColumn,
                               t.endLine,   t.endColumn);
      }
    }
    catch (ParseException pe) {
      _throwParseException(pe, "This is an illegal literal!");
    }
  }
  /**
   * Used internally to parse an expression
   */
  Expression thisExpression() :
  {
    Token t;
  }
  {
    t="this"
    {
      return new ThisExpression(new LinkedList<IdentifierToken>(),
                                filename,
                                t.beginLine, t.beginColumn,
                                t.endLine,   t.endColumn);
    }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression superExpression() :
  {
    Token t;
    Token id;
  }
  {
    t="super" "." id=<IDENTIFIER>
    {
      return new CompileTimeSuperExpression(id.image,
                                            t.beginLine,  t.beginColumn,
                                            id.endLine,   id.endColumn);
    }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression qualifiedName() :
  {
    List<IdentifierToken> list;
  }
  {
    list=name()
    {
      return new CompileTimeQualifiedName(list);
    }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression classExpression() :
  {
    TypeName  typ;
    Token t;
  }
  {
    typ=resultType() "." t="class"
    {
      return new TypeExpression(typ,
                                filename,
                                typ.getBeginLine(), typ.getBeginColumn(),
                                t.endLine,   t.endColumn);
    }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression allocationExpression() :
  {
    Token t;
    ArrayAllocation.TypeDescriptor td;
    TypeName            pt;
    ArgumentsSuffix as;
    ClassBody       cb = null;
    List<TypeName> typeArgs = new LinkedList<TypeName>();
  }
  {
    ( LOOKAHEAD(2)
       t="new" pt=primitiveType() td=arrayDimsAndInits()
       {
      return new ArrayAllocation(pt, td,
                                 filename,
                                 t.beginLine, t.beginColumn,
                                 td.endLine,  td.endColumn);
    }
     |
     t="new"
       [LOOKAHEAD(TypeArguments()) typeArgs = TypeArguments()]
       pt = ReferenceTypeName()
       ( td=arrayDimsAndInits()
          {
       return new ArrayAllocation(pt, td,
                                  filename,
                                  t.beginLine, t.beginColumn,
                                  td.endLine, td.endColumn);
     }
        | as=arguments(typeArgs) [ cb=classBody() ]
          {
          if (cb == null) {
            return new SimpleAllocation(pt, as.arguments,
                                        filename,
                                        t.beginLine, t.beginColumn,
                                        as.endLine,  as.endColumn);
          } else {
            return new ClassAllocation(pt, as.arguments, cb.list,
                                       filename,
                                       t.beginLine, t.beginColumn,
                                       cb.endLine,  cb.endColumn);
          }
        }
        )
       )
  }
  
  /**
   * Used internally to parse an expression
   */
  ArrayAllocation.TypeDescriptor arrayDimsAndInits() :
  {
    List<Expression>  dims = new LinkedList<Expression>();
    int   dim  = 0;
    Token t;
    Expression exp;
    ArrayInitializer ai;
  }
  {
    ( LOOKAHEAD(2)
       ( LOOKAHEAD(2)
          "[" exp=expression() t="]"
          {
      dims.add(exp);
    }
    )+
     ( LOOKAHEAD(2) "[" t="]"
        {
      dim++;
    }
    )*
     {
      return new ArrayAllocation.TypeDescriptor(dims, dim+dims.size(), null,
                                                t.endLine, t.endColumn);
    }
     |
     ( "[" "]"
        {
       dim++;
     }
     )+
     ai=arrayInitializer()
       {
       return new ArrayAllocation.TypeDescriptor
         (dims, dim, ai,
          ai.getEndLine(), ai.getEndColumn());
     }
     )
  }
  
  // Productions for Types ///////////////////////////////////////////////////////////
  
  /**
   * Used internally to parse types
   */
  TypeName type() :
  {
    int   dim = 0;
    TypeName  pt  = null;
    Token t   = null;
    TypeName rt = null;
  }
  {
    ( pt=primitiveType()
       | rt=ReferenceTypeName()
       )
      ( "[" t="]"  /**/ // Why does it complain about conflict here, so we put LOOKAHEAD(2)
         {
      dim++;
    }
    )*
    {
      if (pt != null) {
        rt = pt;
      }
      if (dim == 0) {
        return rt;
      } else {
        return new ArrayTypeName(rt, dim,
                             filename,
                             rt.getBeginLine(), rt.getBeginColumn(),
                             t.endLine,         t.endColumn);
      }
    }
  }
  
  /**
   * Used internally to parse types
   */
  TypeName resultType() :
  {
    TypeName  typ;
    Token t;
  }
  {
    t="void"
    {
      return new VoidTypeName(filename,
                          t.beginLine, t.beginColumn, t.endLine, t.endColumn);
    }
    |
      typ=type()
    {
      return typ;
    }
  }
  
  /**
   * Used internally to parse types
   */
  TypeName primitiveType() :
  {
    Token t;
  }
  {
    t="boolean"
    {
      return new BooleanTypeName(filename,
                             t.beginLine, t.beginColumn, t.endLine, t.endColumn);
    }
    |
      t="char"
    {
      return new CharTypeName(filename,
                          t.beginLine, t.beginColumn, t.endLine, t.endColumn);
    }
    |
      t="byte"
    {
      return new ByteTypeName(filename,
                          t.beginLine, t.beginColumn, t.endLine, t.endColumn);
    }
    |
      t="short"
    {
      return new ShortTypeName(filename,
                           t.beginLine, t.beginColumn, t.endLine, t.endColumn);
    }
    |
      t="int"
    {
      return new IntTypeName(filename,
                         t.beginLine, t.beginColumn, t.endLine, t.endColumn);
    }
    |
      t="long"
    {
      return new LongTypeName(filename,
                          t.beginLine, t.beginColumn, t.endLine, t.endColumn);
    }
    |
      t="float"
    {
      return new FloatTypeName(filename,
                           t.beginLine, t.beginColumn, t.endLine, t.endColumn);
    }
    |
      t="double"
    {
      return new DoubleTypeName(filename,
                            t.beginLine, t.beginColumn, t.endLine, t.endColumn);
    }
  }
  
  
  // Lookahead productions ////////////////////////////////////////////////////////
  
  /**
   * Looks ahead for one top level statement
   */
  void topLevelStatementLookahead() :
  {
  }
  {
    "package" | "import" | "{" | ";" | "if" | "assert" | "while" | "do" | "switch" | "for" | "break" | "continue" | "return" | "throw" | "try"
      |  LOOKAHEAD(2) ("synchronized" "(")
      | LOOKAHEAD(2) (<IDENTIFIER> ":")
      | LOOKAHEAD(methodDeclarationLookahead()) methodDeclarationLookahead()
      | LOOKAHEAD(["final"] typeLookahead() <IDENTIFIER>) (["final"] typeLookahead() <IDENTIFIER>)
      | LOOKAHEAD(typeDeclarationLookahead())  typeDeclarationLookahead()
      | LOOKAHEAD(expression() ";") (expression() ";")
  }
  
  /**
   * Looks ahead for a type declatarion
   */
  void typeDeclarationLookahead() :
  {
  }
  {
    LOOKAHEAD(classDeclarationLookahead()) classDeclarationLookahead()
      | LOOKAHEAD(enumDeclarationLookahead()) enumDeclarationLookahead()
      | LOOKAHEAD(interfaceDeclarationLookahead()) interfaceDeclarationLookahead()
  }
  
  /**
   * Used internally for lookahead
   */
  void castLookahead() :
  {}
  {
    LOOKAHEAD(2)
      "(" primitiveTypeLookahead()
      |
      LOOKAHEAD("(" nameLookahead() "[")
      "(" nameLookahead() "[" "]"
      |
      "(" nameLookahead() ")"
      ( "~" | "!" | "(" | <IDENTIFIER> | "this" | "super" | "new" | literalLookahead() )
  }
  
  /**
   * Used internally for lookahead
   */
  void typeLookahead() :
  {}
  {
    ( primitiveTypeLookahead() | nameLookahead() ) ( "[" "]" )*
  }
  
  /**
   * Used internally for lookahead
   */
  void resultTypeLookahead() :
  {}
  {
    "void" | typeLookahead()
  }
  
  /**
   * Used internally for lookahead
   */
  void nameLookahead() :
  {}
  {
    <IDENTIFIER> [ LOOKAHEAD(TypeArguments()) TypeArguments() ] ( LOOKAHEAD(2) "." <IDENTIFIER> [ LOOKAHEAD(TypeArguments()) TypeArguments() ])*
  }
  
  /**
   * Used internally for lookahead
   */
  void primitiveTypeLookahead() :
  {}
  {
    "boolean" | "char" | "byte" | "short" | "int" | "long" | "float" | "double"
  }
  
  /**
   * Used internally for lookahead
   */
  void literalLookahead() :
  {}
  {
    <INTEGER_LITERAL>
      |
      <LONG_LITERAL>
      |
      <FLOAT_LITERAL>
      |
      <DOUBLE_LITERAL>
      |
      <CHARACTER_LITERAL>
      |
      <STRING_LITERAL>
      |
      "true"
      |
      "false"
      |
      "null"
  }
  
  /**
   * Used internally for lookahead
   */
  void explicitConstructorInvocationLookahead() :
  {}
  {
    LOOKAHEAD( "this" argumentsLookahead() ";" )
      "this" argumentsLookahead() ";"
      |
      [ LOOKAHEAD(2) primaryExpressionLookahead() "." ]
      "super" argumentsLookahead() ";"
  }
  
  /**
   * Used internally for lookahead
   */
  void argumentsLookahead() :
  {}
  {
    "(" [ expressionLookahead() ( "," expressionLookahead() )* ] ")"
  }
  
  /**
   * Used internally for lookahead
   */
  void expressionLookahead() :
  {}
  {
    conditionalExpressionLookahead()
      [  assignmentOperatorLookahead() expressionLookahead() ]
  }
  
  /**
   * Used internally for lookahead
   */
  void assignmentOperatorLookahead() :
  {}
  {
    "=" | "*=" | "/=" | "%=" | "+=" | "-=" | "<<=" | ">>=" | ">>>=" | "&=" | "^=" | "|="
  }
  
  /**
   * Used internally for lookahead
   */
  void conditionalExpressionLookahead() :
  {}
  {
    conditionalOrExpressionLookahead()
      [ "?" expressionLookahead() ":" conditionalExpressionLookahead() ]
  }
  
  /**
   * Used internally for lookahead
   */
  void conditionalOrExpressionLookahead() :
  {}
  {
    conditionalAndExpressionLookahead() ( "||" conditionalAndExpressionLookahead() )*
  }
  
  /**
   * Used internally for lookahead
   */
  void conditionalAndExpressionLookahead() :
  {}
  {
    inclusiveOrExpressionLookahead() ( "&&" inclusiveOrExpressionLookahead() )*
  }
  
  /**
   * Used internally for lookahead
   */
  void inclusiveOrExpressionLookahead() :
  {}
  {
    exclusiveOrExpressionLookahead() ( "|" exclusiveOrExpressionLookahead() )*
  }
  
  /**
   * Used internally for lookahead
   */
  void exclusiveOrExpressionLookahead() :
  {}
  {
    andExpressionLookahead() ( "^" andExpressionLookahead() )*
  }
  
  /**
   * Used internally for lookahead
   */
  void andExpressionLookahead() :
  {}
  {
    equalityExpressionLookahead() ( "&" equalityExpressionLookahead() )*
  }
  
  /**
   * Used internally for lookahead
   */
  void equalityExpressionLookahead() :
  {}
  {
    instanceOfExpressionLookahead() ( ( "==" | "!=" ) instanceOfExpressionLookahead() )*
  }
  
  /**
   * Used internally for lookahead
   */
  void instanceOfExpressionLookahead() :
  {}
  {
    relationalExpressionLookahead() [ "instanceof" typeLookahead() ]
  }
  
  /**
   * Used internally for lookahead
   */
  void relationalExpressionLookahead() :
  {}
  {
    shiftExpressionLookahead()
      ( ( "<" | ">" | "<=" | ">=" ) shiftExpressionLookahead() )*
  }
  
  /**
   * Used internally for lookahead
   */
  void shiftExpressionLookahead() :
  {}
  {
    additiveExpressionLookahead()
      ( ( "<<" | ">>" | ">>>" ) additiveExpressionLookahead() )*
  }
  
  /**
   * Used internally for lookahead
   */
  void additiveExpressionLookahead() :
  {}
  {
    multiplicativeExpressionLookahead()
      ( ( "+" | "-" ) multiplicativeExpressionLookahead() )*
  }
  
  /**
   * Used internally for lookahead
   */
  void multiplicativeExpressionLookahead() :
  {}
  {
    unaryExpressionLookahead() ( ( "*" | "/" | "%" ) unaryExpressionLookahead() )*
  }
  
  /**
   * Used internally for lookahead
   */
  void unaryExpressionLookahead() :
  {}
  {
    ( "+" | "-" ) unaryExpressionLookahead()
      |
      preIncrementExpressionLookahead()
      |
      preDecrementExpressionLookahead()
      |
      unaryExpressionNotPlusMinusLookahead()
  }
  
  /**
   * Used internally for lookahead
   */
  void preIncrementExpressionLookahead() :
  {}
  {
    "++" primaryExpressionLookahead()
  }
  
  /**
   * Used internally for lookahead
   */
  void preDecrementExpressionLookahead() :
  {}
  {
    "--" primaryExpressionLookahead()
  }
  
  /**
   * Used internally for lookahead
   */
  void unaryExpressionNotPlusMinusLookahead() :
  {}
  {
    ( "~" | "!" ) unaryExpressionLookahead()
      |
      LOOKAHEAD( castLookahead() ) castExpressionLookahead()
      |
      postfixExpressionLookahead()
  }
  
  /**
   * Used internally for lookahead
   */
  void postfixExpressionLookahead() :
  {}
  {
    primaryExpressionLookahead() [ "++" | "--" ]
  }
  
  /**
   * Used internally for lookahead
   */
  void castExpressionLookahead() :
  {}
  {
    LOOKAHEAD( "(" primitiveTypeLookahead() )
      "(" typeLookahead() ")" unaryExpressionLookahead()
      |
      "(" typeLookahead() ")" unaryExpressionNotPlusMinusLookahead()
  }
  
  /**
   * Used internally for lookahead
   */
  void primaryExpressionLookahead() :
  {}
  {
    primaryPrefixLookahead() ( LOOKAHEAD(2) primarySuffixLookahead() )*
  }
  
  /**
   * Used internally for lookahead
   */
  void primaryPrefixLookahead() :
  {}
  {
    literalLookahead()
      |
      "this"
      |
      "super" "." <IDENTIFIER>
      |
      "(" expressionLookahead() ")"
      |
      allocationExpressionLookahead()
      |
      LOOKAHEAD( resultTypeLookahead() "." "class" )
      resultTypeLookahead() "." "class"
      |
      nameLookahead()
  }
  
  /**
   * Used internally for lookahead
   */
  void primarySuffixLookahead() :
  {}
  {
    LOOKAHEAD(2) "." "this"
      |
      LOOKAHEAD(2) "." allocationExpressionLookahead()
      |
      "[" expressionLookahead() "]"
      |
      "." <IDENTIFIER>
      |
      argumentsLookahead()
  }
  
  /**
   * Used internally for lookahead
   */
  void allocationExpressionLookahead() :
  {}
  {
    LOOKAHEAD(2) "new" primitiveTypeLookahead() arrayDimsAndInitsLookahead()
      |
      "new" nameLookahead()
      ( arrayDimsAndInitsLookahead()
         | argumentsLookahead() [ "{" ] )
  }
  
  /**
   * Used internally for lookahead
   */
  void initializerLookahead() :
  {}
  {
    [ "static" ] "{"
  }
  
  /**
   * Used internally for lookahead
   */
  void modifiersLookahead() :
  {}
  {
    ( "public"   | "protected" | "private" |  "static"   |
     "abstract" | "final" | "native" |  "synchronized" | "transient" | "volatile" )*
  }
  
  /**
   * Used internally for lookahead
   */
  void constructorDeclarationLookahead() :
  {}
  {
    modifiersLookahead() [ TypeParametersLookahead() ] <IDENTIFIER> "("
  }
  
  /**
   * Used internally for lookahead
   */
  void methodDeclarationLookahead() :
  {}
  {
    modifiersLookahead()
      [ TypeParametersLookahead() ]
      resultTypeLookahead()  <IDENTIFIER>  "("
  }
  
  /**
   * Used internally for lookahead
   */
  void nameListLookahead() :
  {}
  {
    nameLookahead() ( "," nameLookahead() )*
  }
  
  /**
   * Used internally for lookahead
   */
  void methodDeclaratorLookahead() :
  {}
  {
    <IDENTIFIER> formalParametersLookahead() ( "[" "]" )*
  }
  
  /**
   * Used internally for lookahead
   */
  void formalParametersLookahead() :
  {}
  {
    "(" [ formalParameterLookahead() ( "," formalParameterLookahead() )* ] ")"
  }
  
  /**
   * Used internally for lookahead
   */
  void formalParameterLookahead() :
  {}
  {
    [ "final" ] typeLookahead() variableDeclaratorIdLookahead()
  }
  
  void varArgsFormalParameterLookahead() :
  {}
  {
    [ "final" ] typeLookahead() <VAR_ARGS> variableDeclaratorIdLookahead()
  }
  
  /**
   * Used internally for lookahead
   */
  void fieldDeclarationLookahead() :
  {}
  {
    modifiersLookahead()
      typeLookahead() variableDeclaratorLookahead()
      ( "," variableDeclaratorLookahead() )* ";"
  }
  
  /**
   * Used internally for lookahead
   */
  void variableDeclaratorLookahead() :
  {}
  {
    variableDeclaratorIdLookahead() [ "=" variableInitializerLookahead() ]
  }
  
  /**
   * Used internally for lookahead
   */
  void variableDeclaratorIdLookahead() :
  {}
  {
    <IDENTIFIER> ( "[" "]" )*
  }
  
  /**
   * Used internally for lookahead
   */
  void localVariableDeclarationLookahead() :
  {}
  {
    [ "final" ] typeLookahead() variableDeclaratorLookahead()
      ( "," variableDeclaratorLookahead() )*
  }
  
  /**
   * Used internally for lookahead
   */
  void arrayDimsAndInitsLookahead() :
  {}
  {
    LOOKAHEAD(2)
      ( LOOKAHEAD(2) "[" expressionLookahead() "]" )+ ( LOOKAHEAD(2) "[" "]" )*
      |
      ( "[" "]" )+ arrayInitializerLookahead()
  }
  
  /**
   * Used internally for lookahead
   */
  void arrayInitializerLookahead() :
  {}
  {
    "{" [ variableInitializerLookahead()
           ( LOOKAHEAD(2) "," variableInitializerLookahead() )* ] [ "," ] "}"
  }
  
  /**
   * Used internally for lookahead
   */
  void variableInitializerLookahead() :
  {}
  {
    arrayInitializerLookahead() | expressionLookahead()
  }
  
  /**
   * Used internally for lookahead
   */
  void classDeclarationLookahead() :
  {}
  {
    modifiersLookahead() "class"
  }
  
  /**
   * Used internally for lookahead
   */
  void enumDeclarationLookahead() :
  {}
  {
    modifiersLookahead() "enum"
  }
  
  /**
   * Used internally for lookahead
   */
  void interfaceDeclarationLookahead() :
  {}
  {
    modifiersLookahead() "interface"
  }
  
  /* Additions to DynamicJava grammar to parse Generics */
  
  TypeParameter[] TypeParameters() :
  {
    List<TypeParameter> list = new LinkedList<TypeParameter>();
    TypeParameter temp;
  }
  {
    <LESS>
      temp = TypeParameter() { list.add(temp); TypeParamsMap.put(temp.getName(), temp); }
    (
     <COMMA>
     temp = TypeParameter() { list.add(temp); TypeParamsMap.put(temp.getName(), temp); }
    )*
      RightAngledBracket()
    {
      GenericTypesEnv = GenericTypesEnv.extend(TypeParamsMap); // push the map of typename/typeparam to the generic types env
      TypeParamsMap = new HashMap<String, TypeParameter>(); // flush old map
      return (TypeParameter[]) list.toArray(new TypeParameter[0]);
    }
  }
  
  // Does not add the peeked type params to the type environment
  TypeParameter[] TypeParametersLookahead() :
  {
    List<TypeParameter> list = new LinkedList<TypeParameter>();
    TypeParameter temp;
  }
  {
    <LESS>
      temp = TypeParameter() { list.add(temp); }
    (
     <COMMA>
     temp = TypeParameter() { list.add(temp); }
    )*
      RightAngledBracket()
    {
      return (TypeParameter[]) list.toArray(new TypeParameter[0]);
    }
  }
  
  TypeParameter TypeParameter() :
  {
    List<IdentifierToken> name;
    TypeName bound = new ReferenceTypeName("Object");
    Token first = getToken(1);
    List<ReferenceTypeName> interfaceBoundsList = new LinkedList<ReferenceTypeName>();
    ReferenceTypeName interf;
  }
  {
    name = name()
      [
       "extends"
         bound = type()
         ("&" interf = ReferenceTypeName()
            {
      interfaceBoundsList.add(interf);
    }
    )*
       ]
    {
      if(bound instanceof ReferenceTypeName){
        return new TypeParameter(_loc(first), name, (ReferenceTypeName)bound, interfaceBoundsList);
      } else {
        throw new ParseException("Primitives are not allowed as bound"+
                                 "types, and array types are temporarily disabled due to a "+
                                 "DynamicJava AST hierarchy bug!");
      }
    }
  }
  
  List<TypeName> TypeArguments() :
  {
    List<TypeName> typeArgs = new LinkedList<TypeName>();
    ReferenceTypeName hookedType = new ReferenceTypeName("java.lang.Object");
    TypeName temp = new HookTypeName(hookedType, false);
    Token hook = null;
    Token supered = null;
  }
  {
    <LESS>
      (LOOKAHEAD("?") hook="?"
         [("extends"|"super") hookedType = ReferenceTypeName()]
         // added to support wildcards
         |
       ( temp = type()) // should be modified to not allow primitives
         )
    {
      if(hook!= null)
        temp = new HookTypeName(hookedType, (supered!=null));
      typeArgs.add(temp);
      
    }
    
    (
     <COMMA>
     (LOOKAHEAD("?") hook="?"
        [("extends"|"super") hookedType = ReferenceTypeName()]
        |
      (temp = type() ) // should be modified to not allow primitives
        )
       {
      if(hook!= null)
        temp = new HookTypeName(hookedType, (supered!=null));
      typeArgs.add(temp);
    }
    )*
      
      RightAngledBracket()
      
    {
      return typeArgs;
    }
  }
  
  Token RightAngledBracket() :
  {
    Token t;
  }
  {
    ( t=<GREATER_THAN> | t=<RSSHIFT1> | t=<RSSHIFT2> | t=<RUSHIFT1> | t=<RUSHIFT2> | t=<RUSHIFT3> )
    { return t; }
  }